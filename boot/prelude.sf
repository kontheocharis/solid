#primitive
UNIT : TYPE

#primitive
TT : UNIT

-- #primitive
-- IO : [a : Layout] (A : Type a) -> Type ptr

#primitive
SIGMA : (A : TYPE) -> (B : A -> TYPE) -> TYPE

#primitive
PAIR : [A : TYPE] [B : A -> TYPE] (a : A) (b : B a) -> SIGMA A B

#obj
#primitive
Unit : Type zero

#obj
#primitive
tt : Unit

-- Some tests

Nat : TYPE
Nat = (P : TYPE) -> P -> (P -> P) -> P

zeroN : Nat
zeroN N z s = z

succN : Nat -> Nat
succN n N z s = s (n N z s)

rec : (N : TYPE) -> N -> (N -> N) -> Nat -> N
rec N z s n = n N z s

addN : Nat -> Nat -> Nat
addN x y = rec Nat x succN y

add-zero-is-zero : Nat -> Nat
add-zero-is-zero x = addN x zeroN

add-succ-is-succ : Nat -> Nat -> Nat
add-succ-is-succ x y = addN x (succN y)

-- -- Some object-level stuff

#obj
Nt : Type ptr
Nt = (P : Type ptr) -> P -> (P -> P) -> P

#obj
ze : Nt
ze P z s = z

#obj
su : Nt -> Nt
su n P z s = s (n P z s)

#obj
rc : (N : Type ptr) -> N -> (N -> N) -> Nt -> N
rc P z s n = n P z s

#obj
ad : Nt -> Nt -> Nt
ad x y = rc Nt x su y

Vect : TYPE -> Nat -> TYPE
Vect T n = rec TYPE UNIT (\R => (head : T, tail : R)) n

List : TYPE -> TYPE
List T = (length : Nat, contents : Vect T length)

id : [a : Layout] -> Code ([A : Type a] -> A -> A)
id [a] = quote [?] [[A : Type a] (x : A) -> A] (\[A] x => x)
  -- @@Todo: need pruning for this to Not require the implicit arg!
  -- @@Todo: proper lambda, code, quote, splice insertion!

#obj
id2 : [A : Type ptr] -> A -> A
id2 x = x
  
foo : TYPE -> TYPE
foo T = {
  bar : TYPE;
  bar = T;

  bar
} 

()
-- the : (A : TYPE) -> A -> A
-- the A x = x

-- the (TYPE -> TYPE, TYPE -> Nat -> TYPE) (List = List, Vect = Vect) 

-- Synonym for sized types
-- #mta
-- Type : Layout -> Type? (sta zero)
-- Type l = Type? (sta l)

-- Generating data
-- #primitive
-- Make : [b] (A : Type? b) -> Type idx

-- #primitive
-- give : [b] [A : Type b] (a : A) -> Make A

-- #primitive
-- push : [b] [A : Type b] (a : Make A) -> A

-- -- Unit


-- #primitive
-- Unit : (l : Layout?) -> Type? l

-- #primitive
-- tt : [l] -> Unit l

-- -- Irrelevance
-- #primitive
-- Irr : [b] (A : Type? b) -> Type zero

-- #primitive
-- irr : [b] [A : Type b] (a : A) -> Irr A

-- -- Sigma
-- #primitive
-- SIGMA : (A : TYPE) -> (A -> TYPE) -> TYPE

-- #primitive
-- pairS : [A : TYPE] [B : A -> TYPE] (a : A) (b : B a) -> SIGMA A B

-- #primitive
-- fstS : [A] [B] (p : SIGMA A B) -> A

-- #primitive
-- sndS : [A : TYPE] [B : A -> TYPE] (p : SIGMA A B) -> B (fstS p)

-- #primitive
-- Sigma : [a] (A : Type? a) [b] (B : Irr A -> Type? b) -> Type? (seq? a b)

-- #primitive
-- pair : [a] [A] [b] [B] (a : A) (b : B a) -> Sigma A B

-- #primitive
-- fst : [a] [A] [b] [B] (p : SIGMA A B) -> A

-- #primitive
-- snd : [a] [A] [b] [B] (p : SIGMA A B) -> B (fst p)

-- -- IO
-- #primitive
-- IO : [a] (A : Type a) -> Type ptr

-- #primitive
-- io-bind : [a] [A : Type a] (m : IO A) (f : A -> IO b) -> IO b

-- #primitive
-- io-return : [a] [A : Type a] (a : A) -> IO A