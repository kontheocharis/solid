-- The main pipeline of the compiler.
module Pipeline.Compiler

import Pipeline.Core
import Surface.Presyntax
import Surface.Parsing
import Surface.Unelaboration
import Surface.Elaboration
import Common
import Utils
import Core.Base
import Core.Atoms
import Core.Syntax
import Core.Metavariables
import Core.Context
import Core.Typechecking
import Core.Primitives.Definitions
import Core.Primitives.Typing
import Data.Singleton
import Data.SnocList
import Control.Monad.State
import Control.Monad.Error.Either
import Control.App
import Control.App.Console
import Data.HashMap
import System
import System.File
import System.Path
import Lib.HashMap
import Data.DPair
import Data.Maybe
import Debug.Trace

%default covering

-- States in the compiler:

record MetaState where
  constructor MkMetaState
  metaSolvingMode : SolvingMode
  metas : HashMap MetaVar (Maybe (Val [<]))
  counter : Nat

emptyMetaState : MetaState
emptyMetaState = MkMetaState SolvingNotAllowed empty 0
  
withMetaSolvingMode : (sm : SolvingMode) -> MetaState -> (m : MetaState ** m.metaSolvingMode = sm)
withMetaSolvingMode sm (MkMetaState _ metas c) = (MkMetaState sm metas c ** Refl)

export
record CompilerState where
  constructor MkCompilerState
  metaState : MetaState
  loc : Loc
  goals : SnocList Goal
  elabState : ElabState
  definedPrimitives : HashDMap PrimitiveAnyIrr (\p => Op p.arity [<])

emptyCompilerState : CompilerState
emptyCompilerState = MkCompilerState emptyMetaState dummyLoc [<] initialElabState empty

-- Errors in the compiler:
  
record WithMetas (a : Type) where
  constructor MkWithMetas
  metas : Metas
  inner : a
  
covering
(Metas => Show a) => Show (WithMetas a) where
  show (MkWithMetas metas inner) = show inner

public export
compilerErrors : List Error
compilerErrors = [ParseError, WithMetas TcError, WithMetas ElabError, AppHasIO]
  
-- Setup monads:

public export
0 CompOver : Type -> Type -> Type
CompOver s = StateT s (App compilerErrors)

-- Map a lens over a sub-state operation to get a state operation.
mapLens : (s -> s') -> (s' -> s -> s) -> CompOver s' a -> CompOver s a
mapLens fwd back op = do
  s' <- gets fwd
  (s'new, res) <- lift $ runStateT s' op
  modify (back s'new)
  pure res

0 MetaComp : SolvingMode -> Type -> Type
MetaComp sm = CompOver (c : MetaState ** c.metaSolvingMode = sm)
  
public export
0 Comp : Type -> Type
Comp = CompOver CompilerState

covering
liftIO : IO a -> Comp a
liftIO i = lift $ Control.App.primIO i 

-- Implementing stage traits:

[metaCompMetas] HasMetas MetaComp where
  getMeta m = do
    mtas <- gets (metas . fst)
    pure $ join (lookup m mtas)

  noSolving = mapLens
    (\(MkMetaState sm metas c ** Refl)
      => (MkMetaState SolvingNotAllowed metas c ** Refl))
    (\(MkMetaState SolvingNotAllowed metas c ** Refl), _
      => (MkMetaState sm metas c ** Refl))

  setSolution m t = modify
    (\(MkMetaState SolvingAllowed metas c ** Refl)
      => (MkMetaState SolvingAllowed (insert m (Just t) metas) c ** Refl))

  canSolve = do
    (MkMetaState sm _ _ ** Refl) <- get
    pure $ Val sm

  newMeta n = do
    c <- gets (counter . fst)
    let m = case n of
          Nothing => AutoGenerated c
          Just n => UserGiven (c, n)
    new <- modify
      (\(MkMetaState sm metas c ** Refl)
        => (MkMetaState sm (insert m Nothing metas) (c + 1) ** Refl))
    pure m
    
  getAllMetas = do
    mtas <- gets (metas . fst)
    pure $ fromFn (\m => join (lookup m mtas))
    
covering
accessMetas : Comp Metas

Dbg Comp where
  dbg s = do
    mtas <- accessMetas
    let syn = showSyntax @{mtas}
    liftIO $ putStrLn (s @{syn})

HasState Loc Comp where
  put l = modify (\s => { loc := l } s)
  get' = gets (\s => s.loc)

HasState Goals Comp where
  put l = modify (\s => { goals := l } s)
  get' = gets (\s => s.goals)

HasTc Comp where
  metasM = MetaComp

  enterMetas = mapLens
    (\(MkCompilerState m l g e h) => withMetaSolvingMode sm m)
    (\(metaSt' ** _), c => { metaState := metaSt' } c)

  metas = metaCompMetas

  tcError ctx err = do
    l <- gets loc
    mtas <- accessMetas
    lift $ throw (MkWithMetas mtas (MkTcError ctx l err))
    
  definedPrimAnnot p = do
    m <- gets definedPrimitives
    let res = lookup (MkPrimitiveAnyIrr p) m
    case res of
      Just r => pure r
      Nothing => error "Tried to access primitive \{show p} but it has not been defined yet!"

  setDefinedPrimAnnot p v = do
    m <- modify
      (\s =>
        { definedPrimitives
          := insert (MkPrimitiveAnyIrr p) v s.definedPrimitives } s)
    pure ()

accessMetas = enterMetas {sm = SolvingNotAllowed} (getAllMetas @{metaCompMetas})

HasState ElabState Comp where
  put el = modify (\s => { elabState := el } s)
  get' = gets (\s => s.elabState)

HasElab Comp
    
-- Inputs and outputs of the compiler

-- Outputs vary depending on how far we go!
public export
data CompilerOutput : (a : Type) -> Type where
  Start : CompilerOutput Input
  Contents : CompilerOutput (Input, String)
  Parsed : CompilerOutput (Input, PTm)
  Elaborated : CompilerOutput (WithMetas (Atom [<]))
  Staged : CompilerOutput (WithMetas (Val [<]))
  Code : CompilerOutput String
  
public export covering
showCompilerOutput : CompilerOutput a -> Show a
showCompilerOutput Start = %search
showCompilerOutput Contents = %search
showCompilerOutput Parsed = %search
showCompilerOutput Elaborated = %search
showCompilerOutput Staged = %search
showCompilerOutput Code = %search
  
-- All the stages are the outputs in order
public export covering
CompilerStages : Stages CompilerOutput ?
CompilerStages = [Start, Contents, Parsed, Elaborated, Staged, Code]

public export
CompilerStageElem : (o : Type) -> (k : CompilerOutput o) -> Type
CompilerStageElem o k = (Singleton k, Elem CompilerOutput o k CompilerStages)

Show (CompilerOutput k) where
  show Start = "start"
  show Contents = "contents"
  show Parsed = "parsed"
  show Elaborated = "elaborated"
  show Staged = "staged"
  show Code = "code"

public export
allOptions : List String
allOptions = go CompilerStages
  where
    go : Stages CompilerOutput n -> List String
    go [] = []
    go (x :: xs) = show x :: go xs

-- Parse a stage from a string.
public export
fromString : String -> Maybe (t ** c ** CompilerStageElem t c)
fromString "contents" = Just (_ ** Contents ** %search)
fromString "parsed" = Just (_ ** Parsed ** %search)
fromString "elaborated" = Just (_ ** Elaborated ** %search)
fromString "staged" = Just (_ ** Staged ** %search)
fromString "code" = Just (_ ** Code ** %search)
fromString _ = Nothing

-- Compiler stages:

covering
read : Input -> Comp (Input, String)
read i@(FileInput filename) = liftIO $ do
  Right content <- readFile filename
    | Left err => do
        putStrLn $ "Error reading file: " ++ show err
        exitWith (ExitFailure 1)
  pure (i, content)

covering
parse : (Input, String) -> Comp (Input, PTm)
parse (p, input) = case parse topLevelBlock input of
  Right ptm => pure (p, ptm)
  Left err => lift $ throw err

-- @@Todo: cache these

printGoals : SnocList Goal -> Comp ()
printGoals sx = do
  mtas <- accessMetas
  liftIO $ for_ sx $ \s => do
    putStrLn $ show @{showUnelab @{mtas} {unel = unelabGoal}} s
    putStrLn ""

covering
elaborate : (Input, PTm) -> Comp (WithMetas (Atom [<]))
elaborate (FileInput p, ptm) = do
  let sp = fromMaybe "." $ parent p
  set (projectL . startingPathL) (Just sp)
  tm <- elab ptm >>= runTcRoot
  set (projectL . mainL) (Just (MkModule (FileInput p) ptm tm))
  mtas <- accessMetas
  goals <- get Goals
  printGoals goals
  pure $ MkWithMetas mtas tm.tm

covering
stage : WithMetas (Atom [<]) -> Comp (WithMetas (Val [<]))
stage atom = ?stageImpl

covering
codegen : WithMetas (Val [<]) -> Comp String
codegen val = ?codegenImpl

HasElab Comp where
  elabError err = do
    l <- get Loc
    mtas <- accessMetas
    lift $ throw (MkWithMetas mtas (MkElabError err l))

  parseImport s = do
    r <- read s 
    (_, tm) <- parse r
    pure tm
  
  runTcRoot tc = do
    atMode Infer tc emptyContext (InferInput (Just Mta)) <&> (.p)

-- All the stages together in a pipeline
public export covering
compiler : Pipeline CompilerOutput Comp CompilerStages
compiler = (read, parse, elaborate, stage, codegen)

-- Main compilation function: compile until a certain stage.
export covering
compileUntil : Input -> CompilerStageElem out k -> (Show out, IO out)
compileUntil input (Val k, o)
  = (showCompilerOutput k, execCompiler $ runPipelineUntil {m = Comp} compiler o input)
  where
    exitError : PrimIO es => Show a => a -> App es r
    exitError err = do
      putStrLn $ "Error: " ++ show err
      primIO $ exitWith (ExitFailure 1)

    execCompiler : Comp a -> IO a
    execCompiler c = run
      (handle
        (handle
          (handle
            (evalStateT emptyCompilerState c) pure exitError)
            pure exitError)
          pure exitError)