-- The main pipeline of the compiler.
module Pipeline.Compiler

import Pipeline.Core
import Surface.Presyntax
import Surface.Parsing
import Surface.Elaboration
import Common
import Utils
import Core.Base
import Core.Atoms
import Core.Syntax
import Core.Metavariables
import Core.Typechecking
import Data.Singleton
import Control.Monad.State
import Control.Monad.Error.Either
import Control.App
import Control.App.Console
import Data.HashMap
import System
import System.File

-- States in the compiler:

record MetaState where
  constructor MkMetaState
  metaSolvingMode : SolvingMode
  metas : HashMap MetaVar (Maybe (Val [<]))
  counter : Nat

emptyMetaState : MetaState
emptyMetaState = MkMetaState SolvingNotAllowed empty 0
  
withMetaSolvingMode : (sm : SolvingMode) -> MetaState -> (m : MetaState ** m.metaSolvingMode = sm)
withMetaSolvingMode sm (MkMetaState _ metas c) = (MkMetaState sm metas c ** Refl)

export
record CompilerState where
  constructor MkCompilerState
  metaState : MetaState
  loc : Loc
  goals : SnocList Goal

emptyCompilerState : CompilerState
emptyCompilerState = MkCompilerState emptyMetaState dummyLoc [<]

-- Errors in the compiler:

public export
compilerErrors : List Error
compilerErrors = [ParseError, TcError, AppHasIO]
  
-- Setup monads:

public export
0 CompOver : Type -> Type -> Type
CompOver s = StateT s (App compilerErrors)

-- Map a lens over a sub-state operation to get a state operation.
mapLens : (s -> s') -> (s' -> s -> s) -> CompOver s' a -> CompOver s a
mapLens fwd back op = do
  s' <- gets fwd
  (s'new, res) <- lift $ runStateT s' op
  modify (back s'new)
  pure res

0 MetaComp : SolvingMode -> Type -> Type
MetaComp sm = CompOver (c : MetaState ** c.metaSolvingMode = sm)
  
public export
0 Comp : Type -> Type
Comp = CompOver CompilerState

covering
liftIO : IO a -> Comp a
liftIO i = lift $ Control.App.primIO i 

-- Implementing stage traits:

[metaCompMetas] HasMetas MetaComp where
  getMeta m = do
    mtas <- gets (metas . fst)
    pure $ join (lookup m mtas)

  noSolving = mapLens
    (\(MkMetaState sm metas c ** Refl)
      => (MkMetaState SolvingNotAllowed metas c ** Refl))
    (\(MkMetaState SolvingNotAllowed metas c ** Refl), _
      => (MkMetaState sm metas c ** Refl))

  setSolution m t = modify
    (\(MkMetaState SolvingAllowed metas c ** Refl)
      => (MkMetaState SolvingAllowed (insert m (Just t) metas) c ** Refl))

  canSolve = do
    (MkMetaState sm _ _ ** Refl) <- get
    pure $ Val sm

  newMeta n = do
    c <- gets (counter . fst)
    let m = case n of
          Nothing => AutoGenerated c
          Just n => UserGiven (c, n)
    new <- modify
      (\(MkMetaState sm metas c ** Refl)
        => (MkMetaState sm (insert m Nothing metas) (c + 1) ** Refl))
    pure m

[compTc] HasTc Comp where
  metasM = MetaComp

  enterMetas = mapLens
    (\(MkCompilerState m l g) => withMetaSolvingMode sm m)
    (\(metaSt' ** _), c => { metaState := metaSt' } c)

  metas = metaCompMetas

  getGoals = gets goals

  addGoal g = modify (\s => { goals := s.goals :< g } s)

  enterLoc l act = do
    old <- gets loc
    modify (\s => { loc := l } s)
    res <- act
    modify (\s => { loc := old } s)
    pure res

  tcError ctx err = do
    l <- gets loc
    lift $ throw (MkTcError ctx l err)
    
-- Inputs and outputs of the compiler
  
public export
data Input : Type where
  FileInput : (filename : String) -> Input

-- Outputs vary depending on how far we go!
public export
data CompilerOutput : Type -> Type where
  Start : CompilerOutput Input
  Contents : CompilerOutput String
  Parsed : CompilerOutput PTm
  Elaborated : CompilerOutput (Atom [<])
  Staged : CompilerOutput (Val [<])
  Code : CompilerOutput String
  
-- All the stages are the outputs in order
public export covering
CompilerStages : Stages CompilerOutput ?
CompilerStages = [Start, Contents, Parsed, Elaborated, Staged, Code]

public export
CompilerStageElem : (o : Type) -> (k : CompilerOutput o) -> Type
CompilerStageElem o k = Elem CompilerOutput o k CompilerStages

public export
toString : CompilerOutput k -> String
toString Start = "start"
toString Contents = "contents"
toString Parsed = "parsed"
toString Elaborated = "elaborated"
toString Staged = "staged"
toString Code = "code"

public export
allOptions : List String
allOptions = go CompilerStages
  where
    go : Stages CompilerOutput n -> List String
    go [] = []
    go (x :: xs) = toString x :: go xs

-- Parse a stage from a string.
public export
fromString : String -> Maybe (t ** c ** Elem CompilerOutput t c CompilerStages)
fromString "contents" = Just (_ ** Contents ** %search)
fromString "parsed" = Just (_ ** Parsed ** %search)
fromString "elaborated" = Just (_ ** Elaborated ** %search)
fromString "staged" = Just (_ ** Staged ** %search)
fromString "code" = Just (_ ** Code ** %search)
fromString _ = Nothing

-- Compiler stages:

covering
read : Input -> Comp String
read (FileInput filename) = liftIO $ do
  Right content <- readFile filename
    | Left err => do
        putStrLn $ "Error reading file: " ++ show err
        exitWith (ExitFailure 1)
  pure content

covering
parse : String -> Comp PTm
parse input = case parse topLevelBlock input of
  Right ptm => pure ptm
  Left err => lift $ throw err

covering
elaborate : PTm -> Comp (Atom [<])
elaborate ptm = runAt Check (elab @{compTc} ptm) emptyContext mainAnnot

covering
stage : Atom [<] -> Comp (Val [<])
stage atom = ?stageImpl

covering
codegen : Val [<] -> Comp String
codegen val = ?codegenImpl

-- All the stages together in a pipeline
public export covering
compiler : Pipeline CompilerOutput Comp CompilerStages
compiler = (read, parse, elaborate, stage, codegen)
  
-- Main compilation function: compile until a certain stage.
export covering
compileUntil : Input -> CompilerStageElem o k -> IO o
compileUntil input o
  = execCompiler $ runPipelineUntil {m = Comp} compiler o input
  where
    exitError : PrimIO es => Show a => a -> App es r
    exitError err = do
      putStrLn $ "Error: " ++ show err
      primIO $ exitWith (ExitFailure 1)

    execCompiler : Comp a -> IO a
    execCompiler c = run
      (handle
        (handle (evalStateT emptyCompilerState c)
          pure exitError)
        pure exitError)