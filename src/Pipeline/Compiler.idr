module Pipeline.Compiler

import Pipeline.Core
import Surface.Presyntax
import Surface.Parsing
import Surface.Elaboration
import Common
import Core.Base
import Core.Atoms
import Core.Syntax
import Core.Metavariables
import Core.Typechecking
import Data.Singleton
import Control.Monad.State
import Control.Monad.Error.Either
import Control.App
import Data.HashMap

record MetaState where
  constructor MkMetaState
  metaSolvingMode : SolvingMode
  metas : HashMap MetaVar (Maybe (Val [<]))
  counter : Nat

record CompilerState where
  constructor MkCompilerState
  metaState : MetaState
  
0 CompOver : Type -> Type -> Type
CompOver s = StateT s (App [ParseError, TcError])

mapState : (s' -> s) -> (s -> s') -> CompOver s a -> CompOver s' a
mapState f g (ST c) = ST (\x => do
  (y, n) <- c (f x)
  pure (g y, n))
  
0 Comp : Type -> Type
Comp = CompOver CompilerState

0 MetaComp : SolvingMode -> Type -> Type
MetaComp sm = CompOver (c : MetaState ** c.metaSolvingMode = sm)

HasMetas MetaComp where
  getMeta m = do
    mtas <- gets (metas . fst)
    pure $ join (lookup m mtas)

  noSolving = mapState
    (\(MkMetaState sm metas c ** Refl) => (MkMetaState SolvingNotAllowed metas c ** Refl))
    (\(MkMetaState SolvingNotAllowed metas c ** Refl) => (MkMetaState sm metas c ** Refl))

  setSolution m t = modify
    (\(MkMetaState SolvingAllowed metas c ** Refl) => (MkMetaState SolvingAllowed (insert m (Just t) metas) c ** Refl))

  canSolve = do
    (MkMetaState sm _ _ ** Refl) <- get
    pure $ Val sm

  newMeta n = do
    c <- gets (counter . fst)
    let m = case n of
          Nothing => AutoGenerated c
          Just n => UserGiven (c, n)
    new <- modify (\(MkMetaState sm metas c ** Refl) => (MkMetaState sm (insert m Nothing metas) (c + 1) ** Refl))
    pure m


HasTc Comp

data CompilerOutput : Type -> Type where
  Start : CompilerOutput String
  Parsed : CompilerOutput PTm
  Elaborated : CompilerOutput (Atom [<])
  Staged : CompilerOutput (Val [<])
  Code : CompilerOutput String
  
public export
fromString : String -> Maybe (t ** CompilerOutput t)
fromString "start" = Just (_ ** Start)
fromString "parsed" = Just (_ ** Parsed)
fromString "elaborated" = Just (_ ** Elaborated)
fromString "staged" = Just (_ ** Staged)
fromString "code" = Just (_ ** Code)
fromString _ = Nothing
  
public export covering
CompilerStages : Stages CompilerOutput ?
CompilerStages = [Start, Parsed, Elaborated, Staged, Code]

covering
parse : String -> Comp PTm
parse input = case parse topLevelBlock input of
  Right ptm => pure ptm
  Left err => lift $ throw err

covering
elaborate : PTm -> Comp (Atom [<])
elaborate ptm = ?leb

covering
stage : Atom [<] -> Comp (Val [<])
stage atom = ?stageImpl

covering
codegen : Val [<] -> Comp String
codegen val = ?codegenImpl

public export covering
compiler : Pipeline CompilerOutput Comp CompilerStages
compiler = (parse, elaborate, stage, codegen)