-- The main pipeline of the compiler.
module Pipeline.Compiler

import Pipeline.Core
import Surface.Presyntax
import Surface.Parsing
import Surface.Unelaboration
import Surface.Elaboration
import Common
import Utils
import Core.Base
import Core.Atoms
import Core.Syntax
import Core.Metavariables
import Core.Typechecking
import Core.Primitives.Definitions
import Core.Primitives.Typing
import Data.Singleton
import Control.Monad.State
import Control.Monad.Error.Either
import Control.App
import Control.App.Console
import Data.HashMap
import System
import System.File
import Lib.HashMap
import Data.DPair

-- States in the compiler:

record MetaState where
  constructor MkMetaState
  metaSolvingMode : SolvingMode
  metas : HashMap MetaVar (Maybe (Val [<]))
  counter : Nat

emptyMetaState : MetaState
emptyMetaState = MkMetaState SolvingNotAllowed empty 0
  
withMetaSolvingMode : (sm : SolvingMode) -> MetaState -> (m : MetaState ** m.metaSolvingMode = sm)
withMetaSolvingMode sm (MkMetaState _ metas c) = (MkMetaState sm metas c ** Refl)

export
record CompilerState where
  constructor MkCompilerState
  metaState : MetaState
  loc : Loc
  goals : SnocList Goal
  definedPrimitives : HashDMap PrimitiveAny (\p => Op p.arity [<])

emptyCompilerState : CompilerState
emptyCompilerState = MkCompilerState emptyMetaState dummyLoc [<] empty

-- Errors in the compiler:

public export
compilerErrors : List Error
compilerErrors = [ParseError, TcError, AppHasIO]
  
-- Setup monads:

public export
0 CompOver : Type -> Type -> Type
CompOver s = StateT s (App compilerErrors)

-- Map a lens over a sub-state operation to get a state operation.
mapLens : (s -> s') -> (s' -> s -> s) -> CompOver s' a -> CompOver s a
mapLens fwd back op = do
  s' <- gets fwd
  (s'new, res) <- lift $ runStateT s' op
  modify (back s'new)
  pure res

0 MetaComp : SolvingMode -> Type -> Type
MetaComp sm = CompOver (c : MetaState ** c.metaSolvingMode = sm)
  
public export
0 Comp : Type -> Type
Comp = CompOver CompilerState

covering
liftIO : IO a -> Comp a
liftIO i = lift $ Control.App.primIO i 

-- Implementing stage traits:

[metaCompMetas] HasMetas MetaComp where
  getMeta m = do
    mtas <- gets (metas . fst)
    pure $ join (lookup m mtas)

  noSolving = mapLens
    (\(MkMetaState sm metas c ** Refl)
      => (MkMetaState SolvingNotAllowed metas c ** Refl))
    (\(MkMetaState SolvingNotAllowed metas c ** Refl), _
      => (MkMetaState sm metas c ** Refl))

  setSolution m t = modify
    (\(MkMetaState SolvingAllowed metas c ** Refl)
      => (MkMetaState SolvingAllowed (insert m (Just t) metas) c ** Refl))

  canSolve = do
    (MkMetaState sm _ _ ** Refl) <- get
    pure $ Val sm

  newMeta n = do
    c <- gets (counter . fst)
    let m = case n of
          Nothing => AutoGenerated c
          Just n => UserGiven (c, n)
    new <- modify
      (\(MkMetaState sm metas c ** Refl)
        => (MkMetaState sm (insert m Nothing metas) (c + 1) ** Refl))
    pure m

HasTc Comp where
  metasM = MetaComp

  enterMetas = mapLens
    (\(MkCompilerState m l g h) => withMetaSolvingMode sm m)
    (\(metaSt' ** _), c => { metaState := metaSt' } c)

  metas = metaCompMetas

  getGoals = gets goals

  addGoal g = modify (\s => { goals := s.goals :< g } s)

  enterLoc l act = do
    old <- gets loc
    modify (\s => { loc := l } s)
    res <- act
    modify (\s => { loc := old } s)
    pure res

  tcError ctx err = do
    l <- gets loc
    lift $ throw (MkTcError ctx l err)
    
  definedPrimAnnot p = do
    m <- gets definedPrimitives
    let res = lookup (MkPrimitiveAny _ _ _ _ p) m
    case res of
      Just r => pure r
      Nothing => error "Tried to access primitive \{show p} but it has not been defined yet!"

  setDefinedPrimAnnot p v = do
    m <- modify
      (\s =>
        { definedPrimitives
          := insert (MkPrimitiveAny _ _ _ _ p) v s.definedPrimitives } s)
    pure ()
    
HasElab Comp where
    
-- Inputs and outputs of the compiler
  
public export
data Input : Type where
  FileInput : (filename : String) -> Input
  
Show Input where
  show (FileInput filename) = "File input: " ++ filename

-- Outputs vary depending on how far we go!
public export
data CompilerOutput : (a : Type) -> Type where
  Start : CompilerOutput Input
  Contents : CompilerOutput String
  Parsed : CompilerOutput PTm
  Elaborated : CompilerOutput (Atom [<])
  Staged : CompilerOutput (Val [<])
  Code : CompilerOutput String
  
public export covering
showCompilerOutput : CompilerOutput a -> Show a
showCompilerOutput Start = %search
showCompilerOutput Contents = %search
showCompilerOutput Parsed = %search
showCompilerOutput Elaborated = %search
showCompilerOutput Staged = %search
showCompilerOutput Code = %search
  
-- All the stages are the outputs in order
public export covering
CompilerStages : Stages CompilerOutput ?
CompilerStages = [Start, Contents, Parsed, Elaborated, Staged, Code]

public export
CompilerStageElem : (o : Type) -> (k : CompilerOutput o) -> Type
CompilerStageElem o k = (Singleton k, Elem CompilerOutput o k CompilerStages)

Show (CompilerOutput k) where
  show Start = "start"
  show Contents = "contents"
  show Parsed = "parsed"
  show Elaborated = "elaborated"
  show Staged = "staged"
  show Code = "code"

public export
allOptions : List String
allOptions = go CompilerStages
  where
    go : Stages CompilerOutput n -> List String
    go [] = []
    go (x :: xs) = show x :: go xs

-- Parse a stage from a string.
public export
fromString : String -> Maybe (t ** c ** CompilerStageElem t c)
fromString "contents" = Just (_ ** Contents ** %search)
fromString "parsed" = Just (_ ** Parsed ** %search)
fromString "elaborated" = Just (_ ** Elaborated ** %search)
fromString "staged" = Just (_ ** Staged ** %search)
fromString "code" = Just (_ ** Code ** %search)
fromString _ = Nothing

-- Compiler stages:

covering
read : Input -> Comp String
read (FileInput filename) = liftIO $ do
  Right content <- readFile filename
    | Left err => do
        putStrLn $ "Error reading file: " ++ show err
        exitWith (ExitFailure 1)
  pure content

covering
parse : String -> Comp PTm
parse input = case parse topLevelBlock input of
  Right ptm => pure ptm
  Left err => lift $ throw err

covering
elaborate : PTm -> Comp (Atom [<])
elaborate ptm = do
  res <- runAt Check (elab ptm) emptyContext (CheckInput _ mainAnnot)
  pure $ res.tm

covering
stage : Atom [<] -> Comp (Val [<])
stage atom = ?stageImpl

covering
codegen : Val [<] -> Comp String
codegen val = ?codegenImpl

-- All the stages together in a pipeline
public export covering
compiler : Pipeline CompilerOutput Comp CompilerStages
compiler = (read, parse, elaborate, stage, codegen)
  
-- Main compilation function: compile until a certain stage.
export covering
compileUntil : Input -> CompilerStageElem out k -> (Show out, IO out)
compileUntil input (Val k, o)
  = (showCompilerOutput k, execCompiler $ runPipelineUntil {m = Comp} compiler o input)
  where
    exitError : PrimIO es => Show a => a -> App es r
    exitError err = do
      putStrLn $ "Error: " ++ show err
      primIO $ exitWith (ExitFailure 1)

    execCompiler : Comp a -> IO a
    execCompiler c = run
      (handle
        (handle (evalStateT emptyCompilerState c)
          pure exitError)
        pure exitError)