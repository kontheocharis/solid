-- Unelaborating core syntax back to surface syntax
module Surface.Unelaboration

import Utils
import Common
import Decidable.Equality
import Control.Monad.State
import Control.Monad.Reader
import Data.Singleton
import Data.DPair
import Core.Base
import Core.Primitives.Definitions
import Core.Syntax
import Core.Evaluation
import Core.Primitives.Rules
import Core.Context
import Core.Metavariables
import Core.Unification
import Core.Atoms
import Core.Syntax
import Surface.Presyntax

%default covering

-- We need to be able to generate fresh names during unelaboration,
-- and to lookup metas.
public export
interface Monad m => Metas => HasUnelab (0 m : Type -> Type) where
  fresh : m Ident

-- Implemented for each syntactic construct that can be unelaborated to surface syntax.
public export 
interface Unelab (0 t : Ctx -> Type) (0 p : Type) | t where
  unelab : HasUnelab m => {ns : Ctx} -> t ns -> m p
  
public export
[stateUnelab] Metas => HasUnelab (State Int) where
  fresh = do
    n <- get
    put (n + 1)
    pure (Explicit, "x" ++ show n)
  
-- Unelaborate a term locally (the fresh names will vary across invocations!).
export
localUnelab : Metas => (forall m . (HasUnelab m) => m t) -> t
localUnelab op = evalState 0 (op @{stateUnelab})

export
{d : Domain} -> Unelab (Term d) PTm
  
export
{n : Ident} -> Unelab (Body Syntax n) PTm where
  unelab (Delayed t) = unelab t
  
export
{t : Target} -> Unelab term PTm => Unelab (Spine ar term) (PSpine t) where
  unelab [] = pure $ MkPSpine []
  unelab ((Val n, x) :: xs) = case !(unelab xs) of
    MkPSpine xs' => pure $ MkPSpine (MkPArg dummyLoc (Just n) !(unelab x) :: xs')
  
export
{t : Target} -> Unelab term PTm => Unelab (Tel ar term) (PTel t) where
  unelab [] = pure $ MkPTel []
  unelab ((Val n, x) :: xs) = case !(unelab xs) of
    MkPTel xs' => pure $ MkPTel (MkPParam dummyLoc n (Just !(unelab x)) :: xs')

-- We could special case some primitives to make the output nicer.
export
Unelab (PrimitiveApplied k Syntax NA) PTm where
  unelab (p $$ sp) = pure $ pApps (PName (primName p)) !(unelab sp)
    
export
Unelab (Binding s r Syntax) PTm where
  unelab (Bound s InternalLam y) = do
    n <- fresh
    pure $ pLam (MkPParam dummyLoc n Nothing) !(unelab (relabelBody n y))
  unelab (Bound Mta (BindMtaLam n) y) =
    pure $ pLam (MkPParam dummyLoc n Nothing) !(unelab y)
  unelab (Bound Obj (BindObjLam n domBytes codBytes) y) =
    pure $ pLam (MkPParam dummyLoc n Nothing) !(unelab y)
  unelab (Bound Mta (BindMtaLet (_, n) ty rhs) y) =
    pure $ pLet dummyLoc n !(Just <$> unelab ty) !(unelab rhs) !(unelab y)
  unelab (Bound Obj (BindObjLet (_, n) tyBytes ty rhs) y) =
    pure $ pLet dummyLoc n !(Just <$> unelab ty) !(unelab rhs) !(unelab y)
  unelab (Bound Mta (BindMtaPi n dom) y) =
    pure $ pPi (MkPParam dummyLoc n !(Just <$> unelab dom)) !(unelab y)
  unelab (Bound Obj (BindObjPi n domBytes codBytes dom) y) =
    pure $ pPi (MkPParam dummyLoc n !(Just <$> unelab dom)) !(unelab y)
  
public export
{d : Domain} -> Unelab (Term d) PTm

export
Unelab (Head Syntax NA) PTm where
  unelab {ns} (SynVar (Index i)) =
    pure $ let (_, n) = getIdx ns i in PName n
  unelab (SynMeta m) = do
    let mta = lookupMeta m
    case mta of
      Just m => unelab (quote {val = Val} {tm = Tm} m)
      Nothing => case m of
        UserGiven (_, n) => pure $ PHole (Just n)
        AutoGenerated k => pure $ PHole (Just $ "m" ++ show k)
  unelab (SynBinding _ _ b) = unelab b
  unelab (PrimNeutral p) = unelab p
  
export
Unelab (HeadApplied Syntax NA) PTm where
  unelab {ns} (($$) x@(SynMeta m) {ar = ar} sp) = do
    let mta = lookupMeta m
    case mta of
      Just m => do
        let vsp = eval {over = Val} {val = Spine ar Val} (id {sz = ns.size}) sp
        let applied = apps (weak Terminal m) vsp
        unelab (quote {sz = ns.size} {val = Val} {tm = Tm} applied)
      Nothing => pure $ pApps !(unelab x) !(unelab sp)
  unelab (x $$ sp) = pure $ pApps !(unelab x) !(unelab sp)
  
public export
{d : Domain} -> Unelab (Term d) PTm where
  unelab {d = Syntax} (SynApps x) = unelab x
  unelab {d = Syntax} (RigidBinding _ b) = unelab b
  unelab {d = Syntax} (SynPrimNormal x) = unelab x
  unelab {d = Value} {ns = ns} v = unelab (quote {tm = Tm} {sz = ns.size} v)
  
public export
Unelab Atom PTm where
  unelab (Choice a b) = unelab a
  
-- Context

dummy : Size ns => {ar : Arity} -> Spine ar Atom ns
dummy {ar = []} = []
dummy {ar = (x :: xs)} = (Val _, promote (SynPrimNormal (PrimUNIT $$ []))) :: dummy {ar = xs}

export
[unelabContext] {onlyBinds : Bool} -> Unelab (Context bs) PBlockStatements where
  unelab (MkContext (Val [<]) (Val [<]) [<] [<] (MkScope SZ SZ [<]) [<] bs) = pure $ MkPBlockStatements []
  unelab (MkContext (Val (sx :< x)) (Val (bx :< x')) (tys :< ty) (sorts :< sort) (MkScope (SS sb) (SS sn) (Lift zs)) (sts :< s) bs)
    = do
      MkPBlockStatements rest <- unelab (MkContext (Val sx) (Val bx) tys sorts (MkScope sb sn zs) sts dummy)
      ty' <- unelab ty
      let st = PDirSt (fromStage s).asDirective (PDecl dummyLoc (snd x) ty')
      pure $ MkPBlockStatements (rest ++ [st])
  unelab (MkContext (Val (sx :< x)) (Val bx) (tys :< ty) (sorts :< sort) (MkScope sb (SS sn) (zs :< z)) (sts :< s) bs)
    = if onlyBinds
         then unelab (MkContext (Val sx) (Val bx) tys sorts (MkScope sb sn zs) sts dummy)
         else do 
          MkPBlockStatements rest <- unelab (MkContext (Val sx) (Val bx) tys sorts (MkScope sb sn zs) sts dummy)
          ty' <- unelab ty
          tm' <- unelab z
          let st = PDirSt (fromStage s).asDirective (PLet dummyLoc (snd x) (Just ty') tm')
          pure $ MkPBlockStatements (rest ++ [st])
  unelab _ = pure $ MkPBlockStatements []
  
export
[unelabGoal] Unelab (\_ => Goal) PGoal where
  unelab (MkGoal name hole ctx) = do
    let Val _ = ctx.idents
    ctx' <- unelab @{unelabContext {onlyBinds = True}} ctx
    ty' <- unelab hole.annot.ty
    pure $ MkPGoal
      ctx' hole.annot.stage
      (maybe (PName "?_") (\n => PName "?\{n}") name)
      ty'

-- We can thus implement show for anything that can be unelaborated.
public export
[showUnelab] Metas => (ns : Ctx) => (unel : Unelab t p) => Show p => Show (t ns) where
  show x = show (localUnelab (unelab x))
  
public export
%hint
showUnelabAtom : Metas => Show (Atom [<])
showUnelabAtom = showUnelab

public export
%hint
showUnelabVal : Metas => Show (Val [<])
showUnelabVal = showUnelab

public export
%hint
showSyntax : Metas => ShowSyntax
showSyntax @{mtas} = (mtas, showUnelab, showUnelab, showUnelab)