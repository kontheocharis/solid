-- Unelaborating core syntax back to surface syntax
module Surface.Unelaboration

import Utils
import Common
import Decidable.Equality
import Data.Singleton
import Data.DPair
import Core.Base
import Core.Primitives
import Core.Syntax
import Core.Evaluation
import Core.Rules
import Core.Metavariables
import Core.Unification
import Core.Atoms
import Surface.Presyntax

%default covering

-- We need to be able to generate fresh names during unelaboration,
public export
interface Monad m => HasUnelab (0 m : Type -> Type) where
  fresh : m Ident

-- Implemented for each syntactic construct that can be unelaborated to surface syntax.
public export 
interface HasUnelab m => Unelab m (0 t : Ctx -> Type) (0 p : Type) | m, t where
  unelab : {ns : Ctx} -> t ns -> m p

HasUnelab m => Unelab m Tm PTm
  
{n : Ident} -> HasUnelab m => Unelab m (Body Syntax n) PTm where
  unelab (Delayed t) = unelab t
  
{t : Target} -> (HasUnelab m, Unelab m term PTm) => Unelab m (Spine ar term) (PSpine t) where
  unelab [] = pure $ MkPSpine []
  unelab ((Val n, x) :: xs) = case !(unelab xs) of
    MkPSpine xs' => pure $ MkPSpine (MkPArg dummyLoc (Just n) !(unelab x) :: xs')

-- We could special case some primitives to make the output nicer.
HasUnelab m => Unelab m (PrimitiveApplied k Syntax NA) PTm where
  unelab (p $$ sp) = pure $ pApps (PName (primName p)) !(unelab sp)
    
HasUnelab m => Unelab m (Binding s r Syntax) PTm where
  unelab (Bound s InternalLam y) = do
    n <- fresh
    pure $ pLam (MkPParam dummyLoc n Nothing) !(unelab (relabelBody n y))
  unelab (Bound Mta (BindMtaLam n) y) =
    pure $ pLam (MkPParam dummyLoc n Nothing) !(unelab y)
  unelab (Bound Obj (BindObjLam n domBytes codBytes) y) =
    pure $ pLam (MkPParam dummyLoc n Nothing) !(unelab y)
  unelab (Bound Mta (BindMtaLet (_, n) ty rhs) y) =
    pure $ pLet dummyLoc (MkLetFlags (Just Mta) False) n !(Just <$> unelab ty) !(unelab rhs) !(unelab y)
  unelab (Bound Obj (BindObjLet (_, n) tyBytes ty rhs) y) =
    pure $ pLet dummyLoc (MkLetFlags (Just Obj) False) n !(Just <$> unelab ty) !(unelab rhs) !(unelab y)
  unelab (Bound Mta (BindMtaPi n dom) y) =
    pure $ pPi (MkPParam dummyLoc n Nothing) !(unelab y)
  unelab (Bound Obj (BindObjPi n domBytes codBytes dom) y) =
    pure $ pPi (MkPParam dummyLoc n Nothing) !(unelab y)
  
HasUnelab m => Unelab m (Head Syntax NA) PTm where
  unelab {ns} (SynVar (Index i)) =
    pure $ let (_, n) = getIdx ns i in PName n
  unelab (SynMeta (UserGiven (_, n))) =
    pure $ PHole (Just n)
  unelab (SynMeta (AutoGenerated k)) =
    pure $ PHole (Just $ "m" ++ show k)
  unelab (SynBinding _ _ b) = unelab b
  unelab (PrimNeutral p) = unelab p
  
HasUnelab m => Unelab m (HeadApplied Syntax NA) PTm where
  unelab (x $$ sp) = pure $ pApps !(unelab x) !(unelab sp)
  
HasUnelab m => Unelab m Tm PTm where
  unelab (SynApps x) = unelab x
  unelab (RigidBinding _ b) = unelab b
  unelab (SynPrimNormal x) = unelab x