module Surface.Unelaboration

import Utils
import Common
import Decidable.Equality
import Data.Singleton
import Data.DPair
import Core.Base
import Core.Primitives
import Core.Syntax
import Core.Evaluation
import Core.Rules
import Core.Metavariables
import Core.Unification
import Core.Atoms
import Surface.Presyntax

public export
interface Monad m => HasUnelab (0 m : Type -> Type) where
  fresh : m Ident

public export
interface HasUnelab m => Unelab m (t : Ctx -> Type) (p : Type) where
  unelab : {ns : Ctx} -> t ns -> m p

HasUnelab m => Unelab m Tm PTm
  
{n : Ident} -> HasUnelab m => Unelab m (Body Syntax n) PTm where
  unelab (Delayed t) = unelab t
  
HasUnelab m => Unelab m (Head Syntax NA) PTm where
  unelab {ns} (SynVar (Index i))
    = pure $ let (_, n) = getIdx ns i in PName n
  unelab (SynMeta (UserGiven (_, n)))
    = pure $ PHole (Just n)
  unelab (SynMeta (AutoGenerated k))
    = pure $ PHole (Just $ "m" ++ show k)
  unelab (SynBinding s Callable (Bound s InternalLam y)) = do
      n <- fresh
      -- pure $ pLam (MkPParam ?c ?b ?a) !(unelab (relabel (Change n Id) y))
      ?fa
  unelab (SynBinding Mta Callable (Bound Mta (BindMtaLam n) y)) = ?f_10
  unelab (SynBinding Obj Callable (Bound Obj (BindObjLam n domBytes codBytes) y)) = ?f_11
  unelab (SynBinding Mta Thunk (Bound Mta (BindMtaLet n ty rhs) y)) = ?f_12
  unelab (SynBinding Obj Thunk (Bound Obj (BindObjLet n tyBytes ty rhs) y)) = ?f_13
  unelab (SynBinding Mta Rigid (Bound Mta (BindMtaPi n dom) y)) = ?f_14
  unelab (SynBinding Obj Rigid (Bound Obj (BindObjPi n domBytes codBytes dom) y)) = ?f_15
  unelab (PrimNeutral x) = ?f_7
  
HasUnelab m => Unelab m (HeadApplied Syntax NA) PTm where
  unelab (x $$ y) = ?f_3
  
HasUnelab m => Unelab m Tm PTm where
  unelab (SynApps x) = ?f_0
  unelab (RigidBinding md x) = ?f_1
  unelab (SynPrimNormal x) = ?f_2