-- Unelaborating core syntax back to surface syntax
module Surface.Unelaboration

import Utils
import Common
import Decidable.Equality
import Control.Monad.State
import Data.Singleton
import Data.DPair
import Core.Base
import Core.Primitives
import Core.Syntax
import Core.Evaluation
import Core.Rules
import Core.Metavariables
import Core.Unification
import Core.Atoms
import Surface.Presyntax

%default covering

-- We need to be able to generate fresh names during unelaboration,
public export
interface Monad m => HasUnelab (0 m : Type -> Type) where
  fresh : m Ident

-- Implemented for each syntactic construct that can be unelaborated to surface syntax.
public export 
interface Unelab (0 t : Ctx -> Type) (0 p : Type) | t where
  unelab : HasUnelab m => {ns : Ctx} -> t ns -> m p
  
public export
[stateUnelab] HasUnelab (State Int) where
  fresh = do
    n <- get
    put (n + 1)
    pure (Explicit, "x" ++ show n)
  
-- Unelaborate a term locally (the fresh names will vary across invocations!).
export
localUnelab : (forall m . (HasUnelab m) => m t) -> t
localUnelab op = evalState 0 (op @{stateUnelab})

Unelab Tm PTm
  
{n : Ident} -> Unelab (Body Syntax n) PTm where
  unelab (Delayed t) = unelab t
  
{t : Target} -> Unelab term PTm => Unelab (Spine ar term) (PSpine t) where
  unelab [] = pure $ MkPSpine []
  unelab ((Val n, x) :: xs) = case !(unelab xs) of
    MkPSpine xs' => pure $ MkPSpine (MkPArg dummyLoc (Just n) !(unelab x) :: xs')

-- We could special case some primitives to make the output nicer.
Unelab (PrimitiveApplied k Syntax NA) PTm where
  unelab (p $$ sp) = pure $ pApps (PName (primName p)) !(unelab sp)
    
Unelab (Binding s r Syntax) PTm where
  unelab (Bound s InternalLam y) = do
    n <- fresh
    pure $ pLam (MkPParam dummyLoc n Nothing) !(unelab (relabelBody n y))
  unelab (Bound Mta (BindMtaLam n) y) =
    pure $ pLam (MkPParam dummyLoc n Nothing) !(unelab y)
  unelab (Bound Obj (BindObjLam n domBytes codBytes) y) =
    pure $ pLam (MkPParam dummyLoc n Nothing) !(unelab y)
  unelab (Bound Mta (BindMtaLet (_, n) ty rhs) y) =
    pure $ pLet dummyLoc (MkLetFlags (Just Mta) False) n !(Just <$> unelab ty) !(unelab rhs) !(unelab y)
  unelab (Bound Obj (BindObjLet (_, n) tyBytes ty rhs) y) =
    pure $ pLet dummyLoc (MkLetFlags (Just Obj) False) n !(Just <$> unelab ty) !(unelab rhs) !(unelab y)
  unelab (Bound Mta (BindMtaPi n dom) y) =
    pure $ pPi (MkPParam dummyLoc n Nothing) !(unelab y)
  unelab (Bound Obj (BindObjPi n domBytes codBytes dom) y) =
    pure $ pPi (MkPParam dummyLoc n Nothing) !(unelab y)
  
Unelab (Head Syntax NA) PTm where
  unelab {ns} (SynVar (Index i)) =
    pure $ let (_, n) = getIdx ns i in PName n
  unelab (SynMeta (UserGiven (_, n))) =
    pure $ PHole (Just n)
  unelab (SynMeta (AutoGenerated k)) =
    pure $ PHole (Just $ "m" ++ show k)
  unelab (SynBinding _ _ b) = unelab b
  unelab (PrimNeutral p) = unelab p
  
Unelab (HeadApplied Syntax NA) PTm where
  unelab (x $$ sp) = pure $ pApps !(unelab x) !(unelab sp)
  
Unelab Tm PTm where
  unelab (SynApps x) = unelab x
  unelab (RigidBinding _ b) = unelab b
  unelab (SynPrimNormal x) = unelab x
  
Unelab Val PTm where
  unelab {ns = ns} v = unelab (quote {tm = Tm} {sz = ns.size} v)
  
-- We can thus implement show for anything that can be unelaborated.
{ns : Ctx} -> Unelab t p => Show p => Show (t ns) where
  show x = show (localUnelab (unelab x))