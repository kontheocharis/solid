-- Defining the syntax of the core language
module Core.Syntax

import Utils
import Common
import Core.Base
import Core.Primitives.Definitions
import Data.Singleton
import Decidable.Equality
import Decidable.Decidable
import Control.Monad.Identity

%default total

public export
DecEq MetaVar where
  decEq (UserGiven x) (UserGiven y) with (decEq x y)
    decEq (UserGiven x) (UserGiven x) | Yes Refl = Yes Refl
    _ | No contra = No (\Refl => contra Refl)
  decEq (AutoGenerated x) (AutoGenerated y) with (decEq x y)
    decEq (AutoGenerated x) (AutoGenerated x) | Yes Refl = Yes Refl
    _ | No contra = No (\Refl => contra Refl)
  decEq (UserGiven _) (AutoGenerated _) = No (\Refl impossible)
  decEq (AutoGenerated _) (UserGiven _) = No (\Refl impossible)

-- Whether an expression head is reducible
public export
data Reducibility : Type where
  -- Reducible because it is callable with an argument.
  Callable : Reducibility

  -- Reducible because it is a lazy value, it can be forced (i.e. a thunk).
  Thunk : Reducibility
  -- Irreducible, i.e. rigid.
  Rigid : Reducibility

-- Whether we are talking about syntax or values.
--
-- They differ primarily in their representation of open terms. Syntax just uses
-- de-Brujin indices, while Value works like a defunctionalised HOAS, storing
-- some syntax and an environment to evaluate in.
public export
data Domain = Syntax | Value

-- Terms are indexed by domain, rather than having two separate classes.
--
-- They are also indexed by contexts, making them well-scoped.
public export
data Term : Domain -> Ctx -> Type

export infixr 5 $$

-- The list of binders in the language, indexed by stage.
--
-- Each of these might carry some data, which we mostly care about
-- during codegen
public export
data BinderShape : Stage -> Reducibility -> (tm : Ctx -> Type) -> Ident -> Ctx -> Type where
  -- Internal lambda, does not store a name
  InternalLam : BinderShape s Callable tm n ns

  -- Meta-level lambda
  BindMtaLam : (n : Ident) -> BinderShape Mta Callable tm n ns

  -- Object-level lambda
  BindObjLam : (n : Ident) -> (domBytes : tm ns) -> (codBytes : tm ns) -> BinderShape Obj Callable tm n ns

  -- Meta-level let
  BindMtaLet : (n : Ident) -> (ty : tm ns) -> (rhs : tm ns) -> BinderShape Mta Thunk tm n ns

  -- Object-level let
  BindObjLet : (n : Ident) -> (tyBytes : tm ns) -> (ty : tm ns) -> (rhs : tm ns) -> BinderShape Obj Thunk tm n ns

  -- Meta-level pi
  BindMtaPi : (n : Ident) -> (dom : tm ns) -> BinderShape Mta Rigid tm n ns

  -- Object-level pi
  BindObjPi : (n : Ident) -> (domBytes : tm ns) -> (codBytes : tm ns) -> (dom : tm ns) -> BinderShape Obj Rigid tm n ns

public export
0 Binder : Stage -> Reducibility -> Domain -> Ident -> Ctx -> Type
Binder s r d = BinderShape s r (Term d)

public export
traverseBinder : Applicative f => (tm ns -> f (tm' ms)) -> BinderShape md r tm n ns -> f (BinderShape md r tm' n ms)
traverseBinder _ InternalLam = pure InternalLam
traverseBinder _ (BindMtaLam n) = pure (BindMtaLam n)
traverseBinder f (BindObjLam n ba bb) = BindObjLam n <$> f ba <*> f bb
traverseBinder f (BindMtaLet n ty t) = BindMtaLet n <$> f ty <*> f t
traverseBinder f (BindObjLet n bty ty t) = BindObjLet n <$> f bty <*> f ty <*> f t
traverseBinder f (BindMtaPi n a) = BindMtaPi n <$> f a
traverseBinder f (BindObjPi n ba bb a) = BindObjPi n <$> f ba <*> f bb <*> f a

public export
mapBinder : (tm ns -> tm' ms) -> BinderShape md r tm n ns -> BinderShape md r tm' n ms
mapBinder f b = (traverseBinder (Id . f) b).runIdentity

public export
displayIdent : BinderShape md r tm n ns -> Maybe (Singleton n)
displayIdent InternalLam = Nothing
displayIdent (BindMtaLam n) = Just (Val n)
displayIdent (BindObjLam n _ _) = Just (Val n)
displayIdent (BindMtaLet n _ _) = Just (Val n)
displayIdent (BindObjLet n _ _ _) = Just (Val n)
displayIdent (BindObjPi n _ _ _) = Just (Val n)
displayIdent (BindMtaPi n _) = Just (Val n)

-- Variables are de-Brujin indices or levels depending on if we are in value or
-- syntax ~> fast variable lookup during evaluation, and free weakening for
-- values.
public export
data Variable : Domain -> Ctx -> Type where
  Level : Lvl ns -> Variable Value ns
  Index : Idx ns -> Variable Syntax ns

-- A body is basically a term under a binder.
--
-- Either a term with a free variable or a (defunctionalised) delayed
-- evaluation.
public export
data Body : Domain -> Ident -> Ctx -> Type where
  Delayed : Term Syntax (ns :< n) -> Body Syntax n ns
  Closure : Sub ns (Term Value) ms -> Term Syntax (ms :< n) -> Body Value n ns

-- Helper to package a binder with its body.
public export
data Binding : Stage -> Reducibility -> Domain -> Ctx -> Type where
  Bound : (md : Stage) -> Binder md r d n ns -> Body d n ns -> Binding md r d ns

-- Different spine heads, meaning x in `x a1 ... an`, are reduced
-- to different extents.
--
-- Unification might have to look at simplified heads, but code extraction only
-- needs normalised heads. I.e. we never reduce object bindings unless we have to.
public export
data HeadKind : Domain -> Type where
  -- Anything goes in syntax
  NA : HeadKind Syntax
  -- A merely normalised head. This might be unforced.
  Normalised : HeadKind Value
  -- A fully simplified head, fully forced.
  Simplified : HeadKind Value

-- This is a fully applied primitive.
public export
data PrimitiveApplied : PrimitiveClass -> (d : Domain) -> HeadKind d -> Ctx -> Type where
  -- Syntactic primitive
  ($$) : {k : PrimitiveClass} -> {r : PrimitiveReducibility}
    -> Primitive k r na ar
    -> Spine ar (Term Syntax) ns
    -> PrimitiveApplied k Syntax NA ns
  -- Fully simplified primitive value
  SimpApplied : {k : PrimitiveClass} -> {r : PrimitiveReducibility}
    -> Primitive k r na ar
    -> Spine ar (Term Value) ns
    -> PrimitiveApplied k Value Simplified ns
  -- Glued normalised primitive value, which can (definitely) be evaluated further, stored in a lazy value.
  LazyApplied : {k : PrimitiveClass} -> Primitive k PrimReducible na ar
    -> Spine ar (Term Value) ns
    -> Lazy (Term Value ns)
    -> PrimitiveApplied k Value Normalised ns

public export
data Head : (d : Domain) -> HeadKind d -> Ctx -> Type where
  -- Variables and metas are simplified if they are values
  SynVar : Variable Syntax ns -> Head Syntax NA ns
  ValVar : Variable Value ns -> Head Value Simplified ns
  ValVarWithDef : Variable Value ns -> Head Value Normalised ns
  SynMeta : MetaVar -> Head Syntax NA ns
  ValMeta : MetaVar -> Head Value Simplified ns

  -- A syntactic binding
  SynBinding : (s : Stage) -> (r : Reducibility) -> Binding s r Syntax ns -> Head Syntax NA ns

  -- Meta-level callable bindings cannot appear as heads in values.
  --
  -- Thus, all we have are object-level bindings (which are merely normalised because
  -- they can technically be more simplified)
  ObjCallable : Binding Obj Callable Value ns -> Head Value Normalised ns
  ObjLazy : Binding Obj Thunk Value ns -> Head Value Normalised ns

  -- An applied primitive can only be a head if it is neutral.
  PrimNeutral : PrimitiveApplied PrimNeu d e ns -> Head d e ns

-- Head applied to a spine.
namespace HeadApplied
  public export
  data HeadApplied : (d : Domain) -> HeadKind d -> Ctx -> Type where
    ($$) : Head d hk ns -> Spine ar (Term d) ns -> HeadApplied d hk ns

-- A lazy value could be evaluated further.
public export
data LazyValue : Ctx -> Type where
  -- A lazy application with a merely normalised (but not fully simplified) head.
  LazyApps : HeadApplied Value Normalised ns -> Lazy (Term Value ns) -> LazyValue ns
  -- A lazy primitive which might reduce further if its arguments do.
  LazyPrimNormal : PrimitiveApplied PrimNorm Value Normalised ns -> LazyValue ns

-- Extract the fully simplified form of a lazy value.
public export
simplified : LazyValue ns -> Lazy (Term Value ns)
simplified (LazyApps h f) = f
simplified (LazyPrimNormal (LazyApplied _ _ f)) = f

public export
data Term where
  -- Spine applied to syntactic head
  SynApps : HeadApplied Syntax NA ns -> Term Syntax ns

  -- A lazy glued value, which could be evaluated further.
  Glued : LazyValue ns -> Term Value ns

  -- Spine applied to a simplified value head
  --
  -- Cannot be reduced further
  SimpApps : HeadApplied Value Simplified ns -> Term Value ns

  -- Callable meta binding, never applied to a spine
  MtaCallable : Binding Mta Callable Value ns -> Term Value ns

  -- Callable object binding that must be simplified if applied to anything.
  --
  -- If it shouldn't be simplified it should be a GluedApps (ObjCallable ..) instead.
  SimpObjCallable : Binding Obj Callable Value ns -> Term Value ns

  -- Rigid binding, never applied (e.g. Pi).
  RigidBinding : (md : Stage) -> Binding md Rigid d ns -> Term d ns

  -- Normal primitives, never applied.
  SynPrimNormal : PrimitiveApplied PrimNorm Syntax NA ns -> Term Syntax ns
  -- Fully simplified primitives, cannot be reduced further.
  SimpPrimNormal : PrimitiveApplied PrimNorm Value Simplified ns -> Term Value ns

-- Some convenient shorthands

public export
Tm : Ctx -> Type
Tm = Term Syntax

public export
Ty : Ctx -> Type
Ty = Tm

public export
Val : Ctx -> Type
Val = Term Value

public export
ValTy : Ctx -> Type
ValTy = Val

public export
Env : Ctx -> Ctx -> Type
Env ms ns = Sub ms Val ns

-- Helpers to create syntax

public export
internalLam : (0 n : Ident) -> Tm (ns :< n) -> Tm ns
internalLam _ t = SynApps (SynBinding Mta Callable (Bound Mta InternalLam (Delayed t)) $$ [])

public export
closeWithLams : Size ns -> Tm ns -> Tm [<]
closeWithLams SZ t = t
closeWithLams (SS s) t = closeWithLams s (internalLam _ t)

public export
varIdx : Idx ns -> Tm ns
varIdx i = SynApps (SynVar (Index i) $$ [])

public export
varLvl : Lvl ns -> Val ns
varLvl l = SimpApps (ValVar (Level l) $$ [])

public export
sMtaLam : (n : Ident) -> Tm (ns :< n) -> Tm ns
sMtaLam n t = SynApps (SynBinding _ Callable (Bound _ (BindMtaLam n) (Delayed t)) $$ [])

public export
sObjLam : (n : Ident) -> Tm ns -> Tm ns -> Tm (ns :< n) -> Tm ns
sObjLam n ba bb t = SynApps (SynBinding _ Callable (Bound _ (BindObjLam n ba bb) (Delayed t)) $$ [])

public export
vMtaPi : (n : Ident) -> ValTy ns -> Body Value n ns -> ValTy ns
vMtaPi n ty body = RigidBinding _ (Bound _ (BindMtaPi n ty) body)

public export
sMtaPi : (n : Ident) -> Ty ns -> Ty (ns :< n) -> Ty ns
sMtaPi n ty body = SynApps (SynBinding _ Rigid (Bound _ (BindMtaPi n ty) (Delayed body)) $$ [])

public export
sObjPi : (n : Ident) -> Tm ns -> Tm ns -> Ty ns -> Ty (ns :< n) -> Ty ns
sObjPi n ba bb a b = SynApps (SynBinding _ Rigid (Bound _ (BindObjPi n ba bb a) (Delayed b)) $$ [])

public export
vObjPi : (n : Ident) -> Val ns -> Val ns -> ValTy ns -> Body Value n ns -> ValTy ns
vObjPi n ba bb ty body = RigidBinding _ (Bound _ (BindObjPi n ba bb ty) body)

public export
sPrim : {k : PrimitiveClass} -> {r : PrimitiveReducibility} -> Primitive k r na ar -> Spine ar Tm ns -> Tm ns
sPrim {k = PrimNorm} p sp = SynPrimNormal (p $$ sp)
sPrim {k = PrimNeu} p sp = SynApps (PrimNeutral (p $$ sp) $$ [])

public export
sApps : Tm ns -> Spine ar Tm ns -> Tm ns
sApps q [] = q
sApps (SynApps (h $$ sp')) sp = SynApps (h $$ sp' ++ sp)
sApps (RigidBinding md x) sp = error "ill-typed (trying to apply to a rigid binding)"
sApps (SynPrimNormal (x $$ _)) sp = error "ill-typed (trying to apply to a normal primitive: \{primName x})"

public export
vVar : Lvl ns -> Val ns
vVar l = SimpApps (ValVar (Level l) $$ [])

-- We can extend the variable search machinery to the syntax:

public export
var : (n : String) -> {auto prf : In n ns} -> Tm ns
var n {prf = prf} = SynApps (SynVar (Index (idx @{prf})) $$ [])

public export
varApp : (n : String) -> {auto prf : In n ns} -> Ident -> Term Syntax ns -> Tm ns
varApp n {prf = prf} a v = SynApps (SynVar (Index (idx @{prf})) $$ ((::) (Val a, v) []))

  
-- Readonly metas view
export
record Metas where
  constructor MkMetas
  get : MetaVar -> Maybe (Val [<])
  
export
fromFn : (MetaVar -> Maybe (Val [<])) -> Metas
fromFn = MkMetas
  
export
lookupMeta : Metas => MetaVar -> Maybe (Val [<])
lookupMeta @{MkMetas g} m = g m

-- Showing (just traits for now)

public export
0 ShowSyntax : Type
ShowSyntax = (
    Metas,
    {d : _} -> (ns : Ctx) => Show (Term d ns),
    {d : _} -> forall ar . (ns : Ctx) => Show (Spine ar (Term d) ns)
  )

-- Relabeling
export covering
Relabel (Term d)

export covering
Relabel (Binder s r d n) where
  relabel r b = mapBinder (relabel r) b

export covering
Relabel (Body d n) where
  relabel r (Delayed x) = Delayed (relabel (Change _ r) x)
  relabel r (Closure x y) = Closure (r . x) (relabel (Change _ Id) y)

export covering
Relabel (Binding s r d) where
  relabel r (Bound md b body) = Bound md (relabel r b) (relabel r body)
  
export covering
Relabel (PrimitiveApplied c d k) where
  relabel r (p $$ sp) = p $$ relabel r sp
  relabel r (SimpApplied p sp) = SimpApplied p (relabel r sp)
  relabel r (LazyApplied p sp f) = LazyApplied p (relabel r sp) (relabel r f)

export covering
Relabel (Variable d) where
  relabel r (Level l) = Level (relabel r l)
  relabel r (Index i) = Index (relabel r i)

export covering
Relabel (Head d hk) where
  relabel r (SynVar x) = SynVar (relabel r x)
  relabel r (ValVar x) = ValVar (relabel r x)
  relabel r (ValVarWithDef x) = ValVarWithDef (relabel r x)
  relabel r (SynMeta x) = SynMeta x
  relabel r (ValMeta x) = ValMeta x
  relabel r (SynBinding s x y) = SynBinding s x (relabel r y)
  relabel r (ObjCallable x) = ObjCallable (relabel r x)
  relabel r (ObjLazy x) = ObjLazy (relabel r x)
  relabel r (PrimNeutral x) = PrimNeutral (relabel r x)

export covering
Relabel (HeadApplied d hk) where
  relabel r (x $$ y) = relabel r x $$ relabel r y

export covering
Relabel LazyValue where
  relabel r (LazyApps x y) = LazyApps (relabel r x) (relabel r y)
  relabel r (LazyPrimNormal x) = LazyPrimNormal (relabel r x)

export covering
Relabel (Term d) where
  relabel r (SynApps x) = SynApps (relabel r x)
  relabel r (Glued x) = Glued (relabel r x)
  relabel r (SimpApps x) = SimpApps (relabel r x)
  relabel r (MtaCallable x) = MtaCallable (relabel r x)
  relabel r (SimpObjCallable x) = SimpObjCallable (relabel r x)
  relabel r (RigidBinding md x) = RigidBinding md (relabel r x)
  relabel r (SynPrimNormal x) = SynPrimNormal (relabel r x)
  relabel r (SimpPrimNormal x) = SimpPrimNormal (relabel r x)
  
export covering
relabelBody : (0 n' : Ident) -> Body d n ns -> Body d n' ns
relabelBody n' (Delayed t) = Delayed (relabel (Change n' Id) t)
relabelBody n' (Closure sub t) = Closure sub (relabel (Change n' Id) t)

-- Weakening (only for values)
export covering
Weak (Term Value)

export covering
Weak (PrimitiveApplied k Value e) where
  weak e (SimpApplied h sp) = SimpApplied h (weak e sp)
  weak e (LazyApplied h sp gl) = LazyApplied h (weak e sp) (weak e gl)

export covering
Weak (Binder md r Value n) where
  weak e b = mapBinder (weak e) b

export covering
Weak (Variable Value) where
  weak s (Level l) = Level (weak s l)

export covering
Weak (Body Value n) where
  weak e (Closure env t) = Closure (env . e) t

export covering
Weak (Binding md r Value) where
  weak s (Bound {n = n} md bind body) = Bound {n = n} md (weak s bind) (weak s body)

export covering
Weak (Head Value hk) where
  weak s (ValVar v) = ValVar (weak s v)
  weak s (ValVarWithDef v) = ValVarWithDef (weak s v)
  weak s (ValMeta m) = ValMeta m
  weak s (ObjCallable t) = ObjCallable (weak s t)
  weak s (ObjLazy t) = ObjLazy (weak s t)
  weak s (PrimNeutral p) = PrimNeutral (weak s p)

export covering
Weak (HeadApplied Value hk) where
  weak e (h $$ sp) = weak e h $$ weak e sp

export covering
Weak (Term Value) where
  weak e (Glued (LazyApps a f)) = Glued (LazyApps (weak e a) (weak e f))
  weak e (Glued (LazyPrimNormal a)) = Glued (LazyPrimNormal (weak e a))
  weak e (SimpApps a) = SimpApps (weak e a)
  weak e (MtaCallable c) = MtaCallable (weak e c)
  weak e (SimpObjCallable c) = SimpObjCallable (weak e c)
  weak e (RigidBinding md c) = RigidBinding md (weak e c)
  weak e (SimpPrimNormal p) = SimpPrimNormal (weak e p)

-- Thinning
export covering
Thin (Term d)

export covering
Thin (Binder s r d n) where
  thin r b = mapBinder (thin r) b

export covering
Thin (Body d n) where
  thin r (Delayed x) = Delayed (thin (Keep r) x)
  thin r (Closure x y) = Closure (x . r) y

export covering
Thin (Binding s r d) where
  thin r (Bound md b body) = Bound md (thin r b) (thin r body)
  
export covering
Thin (PrimitiveApplied c d k) where
  thin r (p $$ sp) = p $$ thin r sp
  thin r (SimpApplied p sp) = SimpApplied p (thin r sp)
  thin r (LazyApplied p sp f) = LazyApplied p (thin r sp) (thin r f)

export covering
Thin (Variable d) where
  thin r (Level l) = Level (thin r l)
  thin r (Index i) = Index (thin r i)

export covering
Thin (Head d hk) where
  thin r (SynVar x) = SynVar (thin r x)
  thin r (ValVar x) = ValVar (thin r x)
  thin r (ValVarWithDef x) = ValVarWithDef (thin r x)
  thin r (SynMeta x) = SynMeta x
  thin r (ValMeta x) = ValMeta x
  thin r (SynBinding s x y) = SynBinding s x (thin r y)
  thin r (ObjCallable x) = ObjCallable (thin r x)
  thin r (ObjLazy x) = ObjLazy (thin r x)
  thin r (PrimNeutral x) = PrimNeutral (thin r x)

export covering
Thin (HeadApplied d hk) where
  thin r (x $$ y) = thin r x $$ thin r y

export covering
Thin LazyValue where
  thin r (LazyApps x y) = LazyApps (thin r x) (thin r y)
  thin r (LazyPrimNormal x) = LazyPrimNormal (thin r x)

export covering
Thin (Term d) where
  thin r (SynApps x) = SynApps (thin r x)
  thin r (Glued x) = Glued (thin r x)
  thin r (SimpApps x) = SimpApps (thin r x)
  thin r (MtaCallable x) = MtaCallable (thin r x)
  thin r (SimpObjCallable x) = SimpObjCallable (thin r x)
  thin r (RigidBinding md x) = RigidBinding md (thin r x)
  thin r (SynPrimNormal x) = SynPrimNormal (thin r x)
  thin r (SimpPrimNormal x) = SimpPrimNormal (thin r x)