-- Defining the syntax of the core language
module Core.Syntax

import Utils
import Common
import Core.Base
import Data.Singleton
import Decidable.Equality
import Decidable.Decidable
import Control.Monad.Identity

%default total

public export
DecEq MetaVar where
  decEq (UserGiven x) (UserGiven y) with (decEq x y)
    decEq (UserGiven x) (UserGiven x) | Yes Refl = Yes Refl
    _ | No contra = No (\Refl => contra Refl)
  decEq (AutoGenerated x) (AutoGenerated y) with (decEq x y)
    decEq (AutoGenerated x) (AutoGenerated x) | Yes Refl = Yes Refl
    _ | No contra = No (\Refl => contra Refl)
  decEq (UserGiven _) (AutoGenerated _) = No (\Refl impossible)
  decEq (AutoGenerated _) (UserGiven _) = No (\Refl impossible)

-- Whether an expression head is reducible
public export
data Reducibility : Type where
  -- Reducible because it is callable with an argument.
  Callable : Reducibility

  -- Reducible because it is a lazy value, it can be forced (i.e. a thunk).
  Thunk : Reducibility
  -- Irreducible, i.e. rigid.
  Rigid : Reducibility

-- Whether we are talking about syntax or values.
--
-- They differ primarily in their representation of open terms. Syntax just uses
-- de-Brujin indices, while Value works like a defunctionalised HOAS, storing
-- some syntax and an environment to evaluate in.
public export
data Domain = Syntax | Value

-- Terms are indexed by domain, rather than having two separate classes.
--
-- They are also indexed by contexts, making them well-scoped.
public export
data Term : Domain -> Ctx -> Type

-- Primitives are either neutral or normal.
--
-- Neutral primitives might still be applied to other arguments after being fully
-- applied to their arity. For example,
--
-- ifThenElse : (A : Type) -> Bool -> A -> A -> A
--
-- is a primitive of arity 4, but could be applied to more than 2 arguments,
-- for example if we instantiate A with a function type:
--
-- Conversely, normal primitives can never be applied to more arguments than their
-- arity.
public export
data PrimitiveClass = PrimNeu | PrimNorm

-- Whether a primitive is reducible or not.
--
-- If it is redicuble, it might have some computation rules depending on its arguments.
public export
data PrimitiveReducibility = PrimReducible | PrimIrreducible

-- The theory of primitives.
--
-- Consists of a list of operators, each of a specified arity. Equations are
-- given separately later (they are the reduction rules). Will also be given
-- proper types later.
public export
data Primitive : PrimitiveClass -> PrimitiveReducibility -> Arity -> Type

export infixr 5 $$

-- The list of binders in the language, indexed by stage.
--
-- Each of these might carry some data.
public export
data Binder : Stage -> Reducibility -> Domain -> Ident -> Ctx -> Type where
  -- Internal lambda, does not store a name
  InternalLam : Binder s Callable d n ns

  -- Meta or object-level lambda
  BindLam : (n : Ident) -> Binder s Callable d n ns

  -- Meta or object-level let
  BindLet : (n : Ident) -> (ty : Term d ns) -> (rhs : Term d ns) -> Binder s Thunk d n ns

  -- Meta or object-level pi
  BindPi : (n : Ident) -> (dom : Term d ns) -> Binder s Rigid d n ns

public export
traverseBinder : Applicative f => (Term d ns -> f (Term d' ms)) -> Binder md r d n ns -> f (Binder md r d' n ms)
traverseBinder _ InternalLam = pure InternalLam
traverseBinder _ (BindLam n) = pure (BindLam n)
traverseBinder f (BindLet n ty t) = BindLet n <$> (f ty) <*> (f t)
traverseBinder f (BindPi n t) = BindPi n <$> f t

public export
mapBinder : (Term d ns -> Term d' ms) -> Binder md r d n ns -> Binder md r d' n ms
mapBinder f b = (traverseBinder (Id . f) b).runIdentity

public export
displayIdent : Binder md r d n ns -> Maybe (Singleton n)
displayIdent InternalLam = Nothing
displayIdent (BindLam n) = Just (Val n)
displayIdent (BindLet n _ _) = Just (Val n)
displayIdent (BindPi n _) = Just (Val n)

-- Variables are de-Brujin indices or levels depending on if we are in value or
-- syntax ~> fast variable lookup during evaluation, and free weakening for
-- values.
public export
data Variable : Domain -> Ctx -> Type where
  Level : Lvl ns -> Variable Value ns
  Index : Idx ns -> Variable Syntax ns

-- A body is basically a term under a binder.
--
-- Either a term with a free variable or a (defunctionalised) delayed
-- evaluation.
public export
data Body : Domain -> Ident -> Ctx -> Type where
  Delayed : Term Syntax (ns :< n) -> Body Syntax n ns
  Closure : Sub ns (Term Value) ms -> Term Syntax (ms :< n) -> Body Value n ns

-- Helper to package a binder with its body.
public export
data Binding : Stage -> Reducibility -> Domain -> Ctx -> Type where
  Bound : (md : Stage) -> Binder md r d n ns -> Body d n ns -> Binding md r d ns

-- Different spine heads, meaning x in `x a1 ... an`, are reduced
-- to different extents.
--
-- Unification might have to look at simplified heads, but code extraction only
-- needs normalised heads. I.e. we never reduce object bindings unless we have to.
public export
data HeadKind : Domain -> Type where
  -- Anything goes in syntax
  NA : HeadKind Syntax
  -- A merely normalised head. This might be unforced.
  Normalised : HeadKind Value
  -- A fully simplified head, fully forced.
  Simplified : HeadKind Value

-- This is a fully applied primitive.
public export
data PrimitiveApplied : PrimitiveClass -> (d : Domain) -> HeadKind d -> Ctx -> Type where
  -- Syntactic primitive
  ($$) : {k : PrimitiveClass} -> {r : PrimitiveReducibility}
    -> Primitive k r ar
    -> Spine ar (Term Syntax) ns
    -> PrimitiveApplied k Syntax NA ns
  -- Fully simplified primitive value
  SimpApplied : {k : PrimitiveClass} -> {r : PrimitiveReducibility}
    -> Primitive k r ar
    -> Spine ar (Term Value) ns
    -> PrimitiveApplied k Value Simplified ns
  -- Glued normalised primitive value, which can (definitely) be evaluated further, stored in a lazy value.
  LazyApplied : {k : PrimitiveClass} -> Primitive k PrimReducible ar
    -> Spine ar (Term Value) ns
    -> Lazy (Term Value ns)
    -> PrimitiveApplied k Value Normalised ns

public export
data Head : (d : Domain) -> HeadKind d -> Ctx -> Type where
  -- Variables and metas are simplified if they are values
  SynVar : Variable Syntax ns -> Head Syntax NA ns
  ValVar : Variable Value ns -> Head Value Simplified ns
  SynMeta : MetaVar -> Head Syntax NA ns
  ValMeta : MetaVar -> Head Value Simplified ns

  -- A definition, which is unfolded lazily
  ValDef : Variable Value ns -> Head Value Normalised ns

  -- A syntactic binding
  SynBinding : (s : Stage) -> (r : Reducibility) -> Binding s r Syntax ns -> Head Syntax NA ns

  -- Meta-level callable bindings cannot appear as heads in values.
  --
  -- Thus, all we have are object-level bindings (which are merely normalised because
  -- they can technically be more simplified)
  ObjCallable : Binding Obj Callable Value ns -> Head Value Normalised ns
  ObjLazy : Binding Obj Thunk Value ns -> Head Value Normalised ns

  -- An applied primitive can only be a head if it is neutral.
  PrimNeutral : PrimitiveApplied PrimNeu d e ns -> Head d e ns

-- Head applied to a spine.
namespace HeadApplied
  public export
  data HeadApplied : (d : Domain) -> HeadKind d -> Ctx -> Type where
    ($$) : Head d hk ns -> Spine ar (Term d) ns -> HeadApplied d hk ns

-- A lazy value could be evaluated further.
public export
data LazyValue : Ctx -> Type where
  -- A lazy application with a merely normalised (but not fully simplified) head.
  LazyApps : HeadApplied Value Normalised ns -> Lazy (Term Value ns) -> LazyValue ns
  -- A lazy primitive which might reduce further if its arguments do.
  LazyPrimNormal : PrimitiveApplied PrimNorm Value Normalised ns -> LazyValue ns

-- Extract the fully simplified form of a lazy value.
public export
simplified : LazyValue ns -> Lazy (Term Value ns)
simplified (LazyApps h f) = f
simplified (LazyPrimNormal (LazyApplied _ _ f)) = f

public export
data Term where
  -- Spine applied to syntactic head
  SynApps : HeadApplied Syntax NA ns -> Term Syntax ns

  -- A lazy glued value, which could be evaluated further.
  Glued : LazyValue ns -> Term Value ns

  -- Spine applied to a simplified value head
  --
  -- Cannot be reduced further
  SimpApps : HeadApplied Value Simplified ns -> Term Value ns

  -- Callable meta binding, never applied to a spine
  MtaCallable : Binding Mta Callable Value ns -> Term Value ns

  -- Callable object binding that must be simplified if applied to anything.
  --
  -- If it shouldn't be simplified it should be a GluedApps (ObjCallable ..) instead.
  SimpObjCallable : Binding Obj Callable Value ns -> Term Value ns

  -- Rigid binding, never applied (e.g. Pi).
  RigidBinding : (md : Stage) -> Binding md Rigid d ns -> Term d ns

  -- Normal primitives, never applied.
  SynPrimNormal : PrimitiveApplied PrimNorm Syntax NA ns -> Term Syntax ns
  -- Fully simplified primitives, cannot be reduced further, stable under OPEs.
  SimpPrimNormal : PrimitiveApplied PrimNorm Value Simplified ns -> Term Value ns

-- Some convenient shorthands

public export
0 Tm : Ctx -> Type
Tm = Term Syntax

public export
0 Ty : Ctx -> Type
Ty = Tm

public export
0 Val : Ctx -> Type
Val = Term Value

public export
0 ValTy : Ctx -> Type
ValTy = Val

public export
0 Env : Ctx -> Ctx -> Type
Env ms ns = Sub ms Val ns

-- A typed expression at a given stage
public export
record ExprAt (s : Stage) (d : Domain) (dTy : Domain) (ns : Ctx) where
  constructor MkExprAt
  tm : Term d ns
  ty : Term dTy ns

-- Version of ExprAt which also packages the stage
public export
record Expr (d : Domain) (dTy : Domain) (ns : Ctx) where
  constructor MkExpr
  tm : Term d ns
  ty : Term dTy ns
  stage : Stage

-- An annotation is a type and a stage
public export
record Annot (d : Domain) (ns : Ctx) where
  constructor MkAnnot
  ty : Term d ns
  stage : Stage

-- Turn `ExprAt` into `Expr`
public export
packStage : {s : Stage} -> ExprAt s d dTy ns -> Expr d dTy ns
packStage (MkExprAt tm ty) = MkExpr tm ty s

-- Helper to decide which `Expr` to pick based on an optional stage
public export
0 ExprAtMaybe : Maybe Stage -> Domain -> Domain -> Ctx -> Type
ExprAtMaybe Nothing = Expr
ExprAtMaybe (Just s) = ExprAt s

-- Helpers to create syntax

public export
internalLam : (0 n : Ident) -> Term Syntax (ns :< n) -> Term Syntax ns
internalLam _ t = SynApps (SynBinding Mta Callable (Bound Mta InternalLam (Delayed t)) $$ [])

public export
closeWithLams : Size ns -> Term Syntax ns -> Term Syntax [<]
closeWithLams SZ t = t
closeWithLams (SS s) t = closeWithLams s (internalLam _ t)

public export
varLvl : Lvl ns -> Val ns
varLvl l = SimpApps (ValVar (Level l) $$ [])

public export
sLam : Stage -> (n : Ident) -> Term Syntax (ns :< n) -> Term Syntax ns
sLam s n t = SynApps (SynBinding s Callable (Bound s (BindLam n) (Delayed t)) $$ [])

public export
vPi : Stage -> (n : Ident) -> ValTy ns -> Body Value n ns -> Term Value ns
vPi s n ty body = RigidBinding s (Bound s (BindPi n ty) body)

public export
sPi : Stage -> (n : Ident) -> Ty ns -> Ty (ns :< n) -> Ty ns
sPi s n ty body = SynApps (SynBinding s Rigid (Bound s (BindPi n ty) (Delayed body)) $$ [])

-- We can extend the variable search machinery to the syntax:

public export
var : (n : String) -> {auto prf : In n ns} -> Tm ns
var n {prf = prf} = SynApps (SynVar (Index (idx @{prf})) $$ [])

public export
varApp : (n : String) -> {auto prf : In n ns} -> Ident -> Term Syntax ns -> Tm ns
varApp n {prf = prf} a v = SynApps (SynVar (Index (idx @{prf})) $$ ((::) {a = a} v []))

-- Finally we define the primitives:
data Primitive where
  PrimTYPE : Primitive PrimNorm PrimIrreducible []
  PrimCode : Primitive PrimNorm PrimIrreducible [(Implicit, "bytes"), (Explicit, "ty")]
  PrimQuote : Primitive PrimNorm PrimIrreducible [(Implicit, "bytes"), (Implicit, "ty"), (Explicit, "val")]
  PrimSplice : Primitive PrimNorm PrimIrreducible [(Implicit, "bytes"), (Implicit, "ty"), (Explicit, "val")]
  PrimBYTES : Primitive PrimNorm PrimIrreducible []
  PrimZeroBYTES : Primitive PrimNorm PrimIrreducible []
  PrimSizeBYTES : Primitive PrimNorm PrimIrreducible []
  PrimPtrBYTES : Primitive PrimNorm PrimIrreducible []
  PrimBytes : Primitive PrimNorm PrimIrreducible []
  PrimUNIT : Primitive PrimNorm PrimIrreducible []
  PrimTT : Primitive PrimNorm PrimIrreducible []
  PrimPadTy : Primitive PrimNorm PrimIrreducible [(Explicit, "bytes")]
  PrimPad : Primitive PrimNorm PrimIrreducible [(Implicit, "bytes")]
  PrimIrrTy : Primitive PrimNorm PrimIrreducible [(Implicit, "bytes"), (Explicit, "ty")]
  PrimIrr : Primitive PrimNorm PrimIrreducible [(Implicit, "bytes"), (Implicit, "ty"), (Explicit, "val")]
  PrimEmbedBYTES : Primitive PrimNorm PrimIrreducible [(Explicit, "staticBytes")]
  PrimUnsized : Primitive PrimNorm PrimIrreducible [(Explicit, "bytes")]
  PrimAddBYTES : Primitive PrimNorm PrimReducible [(Explicit, "a"), (Explicit, "b")]
  PrimAddBytes : Primitive PrimNorm PrimReducible [(Explicit, "a"), (Explicit, "b")]
  PrimSIGMA : (a : Name) -> Primitive PrimNorm PrimIrreducible [(Explicit, a), (Explicit, "rest")]
  PrimPAIR : (a : Name) -> Primitive PrimNorm PrimIrreducible
    [(Implicit, a), (Implicit, "rest"), (Explicit, "va"), (Explicit, "vrest")]
  PrimSigma : (a : Name) -> Primitive PrimNorm PrimIrreducible
    [(Implicit, "ba"), (Implicit, "bRest"), (Explicit, a), (Explicit, "rest")]
  PrimPair : (a : Name) -> Primitive PrimNorm PrimIrreducible
    [(Implicit, "ba"), (Implicit, "bRest"), (Implicit, a), (Implicit, "rest"), (Explicit, "va"), (Explicit, "vrest")]

-- Can't be DecEq without writing out all cases smh
public export
primEq : (a : Primitive k r ar) -> (b : Primitive k' r' ar') -> Maybe (a = b)
primEq PrimCode PrimCode = Just Refl
primEq PrimQuote PrimQuote = Just Refl
primEq PrimSplice PrimSplice = Just Refl
primEq PrimTYPE PrimTYPE = Just Refl
primEq PrimBYTES PrimBYTES = Just Refl
primEq PrimZeroBYTES PrimZeroBYTES = Just Refl
primEq PrimSizeBYTES PrimSizeBYTES = Just Refl
primEq PrimPtrBYTES PrimPtrBYTES = Just Refl
primEq PrimUNIT PrimUNIT = Just Refl
primEq PrimTT PrimTT = Just Refl
primEq PrimIrrTy PrimIrrTy = Just Refl
primEq PrimIrr PrimIrr = Just Refl
primEq PrimPadTy PrimPadTy = Just Refl
primEq PrimPad PrimPad = Just Refl
primEq PrimBytes PrimBytes = Just Refl
primEq PrimEmbedBYTES PrimEmbedBYTES = Just Refl
primEq (PrimSigma x) (PrimSigma x') = case decEq x x' of
  Yes Refl => Just Refl
  No contra => Nothing
primEq PrimUnsized PrimUnsized = Just Refl
primEq PrimAddBYTES PrimAddBYTES = Just Refl
primEq PrimAddBytes PrimAddBytes = Just Refl
primEq _ _ = Nothing

-- Some shorthands

public export
sCode : Tm ns -> Tm ns -> Tm ns
sCode by ty = SynPrimNormal (PrimCode $$ [by, ty])

public export
sQuote : Tm ns -> Tm ns -> Tm ns -> Tm ns
sQuote by ty val = SynPrimNormal (PrimQuote $$ [by, ty, val])

public export
sSplice : Tm ns -> Tm ns -> Tm ns -> Tm ns
sSplice by ty val = SynPrimNormal (PrimSplice $$ [by, ty, val])

-- Compile-time bytes as partially-static
public export
embedBytes : Tm ns -> Tm ns
embedBytes b = SynPrimNormal (PrimEmbedBYTES $$ [b])

public export
mtaBytes : Ty ns
mtaBytes = SynPrimNormal (PrimBYTES $$ [])

public export
psBytes : Tm ns
psBytes = SynPrimNormal (PrimBytes $$ [])

-- `Type b` for some *compile-time* byte size `b`, object-level type of types.
public export
sizedObjType : (b : Tm ns) -> Ty ns
sizedObjType b = SynPrimNormal (PrimUnsized $$ [embedBytes b])

public export
objType : Tm ns -> Ty ns
objType b = SynPrimNormal (PrimUnsized $$ [b])

-- The `0` bytes value.
public export
zeroBytes : Tm ns
zeroBytes = SynPrimNormal (PrimZeroBYTES $$ [])

public export
sizeBytes : Tm ns
sizeBytes = SynPrimNormal (PrimSizeBYTES $$ [])

public export
ptrBytes :  Tm ns
ptrBytes = SynPrimNormal (PrimPtrBYTES $$ [])

-- `TYPE`, meta-level type of types.
public export
mtaType : Ty ns
mtaType = SynPrimNormal (PrimTYPE $$ [])

-- Get either `Type 0` or `TYPE` depending on the stage.
public export
typeForStage : Stage -> Ty ns
typeForStage Mta = mtaType
typeForStage Obj = sizedObjType zeroBytes

public export
mtaUnit : Ty ns
mtaUnit = SynPrimNormal (PrimUNIT $$ [])

public export
psBytesAdd : Tm ns -> Tm ns -> Tm ns
psBytesAdd a b = SynPrimNormal (PrimAddBytes $$ [a, b])

public export
primN : PrimitiveApplied PrimNorm Syntax NA ns -> Term Syntax ns
primN = SynPrimNormal

public export
unitForStage : Stage -> Ty ns
unitForStage Mta = primN $ (PrimUNIT $$ [])
unitForStage Obj = primN $ (PrimPadTy $$ [embedBytes zeroBytes])

public export
ttForStage : Stage -> Ty ns
ttForStage Mta = primN $ (PrimTT $$ [])
ttForStage Obj = primN $ (PrimPad $$ [embedBytes zeroBytes])

-- Types of the arguments and return values of all the primitives
public export
primTy : (p : Primitive k r ar) -> (Tel ar (Annot Syntax) ns, Annot Syntax (ns ::< ar))
primTy PrimTYPE = ([], MkAnnot mtaType Mta)
primTy PrimCode = ([MkAnnot psBytes Obj, MkAnnot (objType (var "bytes")) Obj], MkAnnot mtaType Mta)
primTy PrimQuote = ([MkAnnot psBytes Obj, MkAnnot (objType (var "bytes")) Obj, MkAnnot (var "ty") Obj], MkAnnot (sCode (var "bytes") (var "ty")) Mta)
primTy PrimSplice = ([MkAnnot psBytes Obj, MkAnnot (objType (var "bytes")) Obj, MkAnnot (sCode (var "bytes") (var "ty")) Mta], MkAnnot (var "ty") Obj)
primTy PrimBYTES = ([], MkAnnot mtaType Mta)
primTy PrimZeroBYTES = ([], MkAnnot mtaBytes Mta)
primTy PrimSizeBYTES = ([], MkAnnot mtaBytes Mta)
primTy PrimPtrBYTES = ([], MkAnnot mtaBytes Mta)
primTy PrimBytes = ([], MkAnnot (sizedObjType sizeBytes) Obj)
primTy PrimUNIT = ([], MkAnnot mtaType Mta)
primTy PrimTT = ([], MkAnnot mtaUnit Mta)
primTy PrimIrrTy = ([MkAnnot psBytes Obj, MkAnnot (sizedObjType (var "bytes")) Obj], MkAnnot (sizedObjType zeroBytes) Obj)
primTy PrimIrr = ([MkAnnot psBytes Obj, MkAnnot (sizedObjType (var "bytes")) Obj, MkAnnot (var "ty") Obj], MkAnnot (primN (PrimIrrTy $$ [var "bytes", var "ty"])) Obj)
primTy PrimPadTy = ([MkAnnot psBytes Obj], MkAnnot (sizedObjType (var "bytes")) Obj)
primTy PrimPad = ([MkAnnot psBytes Obj], MkAnnot (primN (PrimPadTy $$ [var "bytes"])) Obj)
primTy PrimEmbedBYTES = ([MkAnnot mtaBytes Mta], MkAnnot psBytes Obj)
primTy PrimUnsized = ([MkAnnot psBytes Obj], MkAnnot (sizedObjType zeroBytes) Obj)
primTy PrimAddBYTES = ([MkAnnot mtaBytes Mta, MkAnnot mtaBytes Mta], MkAnnot mtaBytes Mta)
primTy PrimAddBytes = ([MkAnnot psBytes Obj, MkAnnot psBytes Obj], MkAnnot psBytes Obj)
primTy (PrimSIGMA a) = ([MkAnnot mtaType Mta, MkAnnot (sPi Mta (Explicit, "x") (var a) mtaType) Mta], MkAnnot mtaType Mta)
primTy (PrimPAIR a) = ([
    MkAnnot mtaType Mta,
    MkAnnot (sPi Mta (Explicit, "x") (var a) mtaType) Mta,
    MkAnnot (var a) Mta,
    MkAnnot (varApp "rest" (Explicit, "x") (var "va")) Mta
  ], MkAnnot (primN (PrimSIGMA a $$ [var a, var "rest"])) Mta)
primTy (PrimSigma a) = ([
    MkAnnot psBytes Obj,
    MkAnnot psBytes Obj,
    MkAnnot (objType (var "ba")) Obj,
    MkAnnot (sPi Mta (Explicit, "x") (var a) (objType (var "bRest"))) Obj
  ], MkAnnot (objType (psBytesAdd (var "ba") (var "bRest"))) Obj)
primTy (PrimPair a) = ([
    MkAnnot psBytes Obj,
    MkAnnot psBytes Obj,
    MkAnnot (objType (var "ba")) Obj,
    MkAnnot (sPi Mta (Explicit, "x") (var a) (objType (var "bRest"))) Obj,
    MkAnnot (var a) Obj,
    MkAnnot (varApp "rest" (Explicit, "x") (var "va")) Obj
  ], MkAnnot (primN (PrimSigma a $$ [var "ba", var "bRest", var a, var "rest"])) Obj)
