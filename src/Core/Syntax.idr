-- Defining the syntax of the core language
module Core.Syntax

import Utils
import Common
import Core.Base
import Core.Primitives
import Data.Singleton
import Decidable.Equality
import Decidable.Decidable
import Control.Monad.Identity

%default total

public export
DecEq MetaVar where
  decEq (UserGiven x) (UserGiven y) with (decEq x y)
    decEq (UserGiven x) (UserGiven x) | Yes Refl = Yes Refl
    _ | No contra = No (\Refl => contra Refl)
  decEq (AutoGenerated x) (AutoGenerated y) with (decEq x y)
    decEq (AutoGenerated x) (AutoGenerated x) | Yes Refl = Yes Refl
    _ | No contra = No (\Refl => contra Refl)
  decEq (UserGiven _) (AutoGenerated _) = No (\Refl impossible)
  decEq (AutoGenerated _) (UserGiven _) = No (\Refl impossible)

-- Whether an expression head is reducible
public export
data Reducibility : Type where
  -- Reducible because it is callable with an argument.
  Callable : Reducibility

  -- Reducible because it is a lazy value, it can be forced (i.e. a thunk).
  Thunk : Reducibility
  -- Irreducible, i.e. rigid.
  Rigid : Reducibility

-- Whether we are talking about syntax or values.
--
-- They differ primarily in their representation of open terms. Syntax just uses
-- de-Brujin indices, while Value works like a defunctionalised HOAS, storing
-- some syntax and an environment to evaluate in.
public export
data Domain = Syntax | Value

-- Terms are indexed by domain, rather than having two separate classes.
--
-- They are also indexed by contexts, making them well-scoped.
public export
data Term : Domain -> Ctx -> Type

export infixr 5 $$

-- The list of binders in the language, indexed by stage.
--
-- Each of these might carry some data, which we mostly care about
-- during codegen
public export
data Binder : Stage -> Reducibility -> Domain -> Ident -> Ctx -> Type where
  -- Internal lambda, does not store a name
  InternalLam : Binder s Callable d n ns

  -- Meta-level lambda
  BindMtaLam : (n : Ident) -> Binder Mta Callable d n ns

  -- Object-level lambda
  BindObjLam : (n : Ident) -> (domBytes : Term d ns) -> (codBytes : Term d ns) -> Binder Obj Callable d n ns

  -- Meta-level let
  BindMtaLet : (n : Ident) -> (ty : Term d ns) -> (rhs : Term d ns) -> Binder Mta Thunk d n ns

  -- Object-level let
  BindObjLet : (n : Ident) -> (tyBytes : Term d ns) -> (ty : Term d ns) -> (rhs : Term d ns) -> Binder Obj Thunk d n ns

  -- Meta-level pi
  BindMtaPi : (n : Ident) -> (dom : Term d ns) -> Binder Mta Rigid d n ns

  -- Object-level pi
  BindObjPi : (n : Ident) -> (domBytes : Term d ns) -> (codBytes : Term d ns) -> (dom : Term d ns) -> Binder Obj Rigid d n ns

public export
traverseBinder : Applicative f => (Term d ns -> f (Term d' ms)) -> Binder md r d n ns -> f (Binder md r d' n ms)
traverseBinder _ InternalLam = pure InternalLam
traverseBinder _ (BindMtaLam n) = pure (BindMtaLam n)
traverseBinder f (BindObjLam n ba bb) = BindObjLam n <$> f ba <*> f bb
traverseBinder f (BindMtaLet n ty t) = BindMtaLet n <$> f ty <*> f t
traverseBinder f (BindObjLet n bty ty t) = BindObjLet n <$> f bty <*> f ty <*> f t
traverseBinder f (BindMtaPi n a) = BindMtaPi n <$> f a
traverseBinder f (BindObjPi n ba bb a) = BindObjPi n <$> f ba <*> f bb <*> f a

public export
mapBinder : (Term d ns -> Term d' ms) -> Binder md r d n ns -> Binder md r d' n ms
mapBinder f b = (traverseBinder (Id . f) b).runIdentity

public export
displayIdent : Binder md r d n ns -> Maybe (Singleton n)
displayIdent InternalLam = Nothing
displayIdent (BindMtaLam n) = Just (Val n)
displayIdent (BindObjLam n _ _) = Just (Val n)
displayIdent (BindMtaLet n _ _) = Just (Val n)
displayIdent (BindObjLet n _ _ _) = Just (Val n)
displayIdent (BindObjPi n _ _ _) = Just (Val n)
displayIdent (BindMtaPi n _) = Just (Val n)

-- Variables are de-Brujin indices or levels depending on if we are in value or
-- syntax ~> fast variable lookup during evaluation, and free weakening for
-- values.
public export
data Variable : Domain -> Ctx -> Type where
  Level : Lvl ns -> Variable Value ns
  Index : Idx ns -> Variable Syntax ns

-- A body is basically a term under a binder.
--
-- Either a term with a free variable or a (defunctionalised) delayed
-- evaluation.
public export
data Body : Domain -> Ident -> Ctx -> Type where
  Delayed : Term Syntax (ns :< n) -> Body Syntax n ns
  Closure : Sub ns (Term Value) ms -> Term Syntax (ms :< n) -> Body Value n ns

-- Helper to package a binder with its body.
public export
data Binding : Stage -> Reducibility -> Domain -> Ctx -> Type where
  Bound : (md : Stage) -> Binder md r d n ns -> Body d n ns -> Binding md r d ns

-- Different spine heads, meaning x in `x a1 ... an`, are reduced
-- to different extents.
--
-- Unification might have to look at simplified heads, but code extraction only
-- needs normalised heads. I.e. we never reduce object bindings unless we have to.
public export
data HeadKind : Domain -> Type where
  -- Anything goes in syntax
  NA : HeadKind Syntax
  -- A merely normalised head. This might be unforced.
  Normalised : HeadKind Value
  -- A fully simplified head, fully forced.
  Simplified : HeadKind Value

-- This is a fully applied primitive.
public export
data PrimitiveApplied : PrimitiveClass -> (d : Domain) -> HeadKind d -> Ctx -> Type where
  -- Syntactic primitive
  ($$) : {k : PrimitiveClass} -> {r : PrimitiveReducibility}
    -> Primitive k r ar
    -> Spine ar (Term Syntax) ns
    -> PrimitiveApplied k Syntax NA ns
  -- Fully simplified primitive value
  SimpApplied : {k : PrimitiveClass} -> {r : PrimitiveReducibility}
    -> Primitive k r ar
    -> Spine ar (Term Value) ns
    -> PrimitiveApplied k Value Simplified ns
  -- Glued normalised primitive value, which can (definitely) be evaluated further, stored in a lazy value.
  LazyApplied : {k : PrimitiveClass} -> Primitive k PrimReducible ar
    -> Spine ar (Term Value) ns
    -> Lazy (Term Value ns)
    -> PrimitiveApplied k Value Normalised ns

public export
data Head : (d : Domain) -> HeadKind d -> Ctx -> Type where
  -- Variables and metas are simplified if they are values
  SynVar : Variable Syntax ns -> Head Syntax NA ns
  ValVar : Variable Value ns -> Head Value Simplified ns
  SynMeta : MetaVar -> Head Syntax NA ns
  ValMeta : MetaVar -> Head Value Simplified ns

  -- A definition, which is unfolded lazily
  ValDef : Variable Value ns -> Head Value Normalised ns

  -- A syntactic binding
  SynBinding : (s : Stage) -> (r : Reducibility) -> Binding s r Syntax ns -> Head Syntax NA ns

  -- Meta-level callable bindings cannot appear as heads in values.
  --
  -- Thus, all we have are object-level bindings (which are merely normalised because
  -- they can technically be more simplified)
  ObjCallable : Binding Obj Callable Value ns -> Head Value Normalised ns
  ObjLazy : Binding Obj Thunk Value ns -> Head Value Normalised ns

  -- An applied primitive can only be a head if it is neutral.
  PrimNeutral : PrimitiveApplied PrimNeu d e ns -> Head d e ns

-- Head applied to a spine.
namespace HeadApplied
  public export
  data HeadApplied : (d : Domain) -> HeadKind d -> Ctx -> Type where
    ($$) : Head d hk ns -> Spine ar (Term d) ns -> HeadApplied d hk ns

-- A lazy value could be evaluated further.
public export
data LazyValue : Ctx -> Type where
  -- A lazy application with a merely normalised (but not fully simplified) head.
  LazyApps : HeadApplied Value Normalised ns -> Lazy (Term Value ns) -> LazyValue ns
  -- A lazy primitive which might reduce further if its arguments do.
  LazyPrimNormal : PrimitiveApplied PrimNorm Value Normalised ns -> LazyValue ns

-- Extract the fully simplified form of a lazy value.
public export
simplified : LazyValue ns -> Lazy (Term Value ns)
simplified (LazyApps h f) = f
simplified (LazyPrimNormal (LazyApplied _ _ f)) = f

public export
data Term where
  -- Spine applied to syntactic head
  SynApps : HeadApplied Syntax NA ns -> Term Syntax ns

  -- A lazy glued value, which could be evaluated further.
  Glued : LazyValue ns -> Term Value ns

  -- Spine applied to a simplified value head
  --
  -- Cannot be reduced further
  SimpApps : HeadApplied Value Simplified ns -> Term Value ns

  -- Callable meta binding, never applied to a spine
  MtaCallable : Binding Mta Callable Value ns -> Term Value ns

  -- Callable object binding that must be simplified if applied to anything.
  --
  -- If it shouldn't be simplified it should be a GluedApps (ObjCallable ..) instead.
  SimpObjCallable : Binding Obj Callable Value ns -> Term Value ns

  -- Rigid binding, never applied (e.g. Pi).
  RigidBinding : (md : Stage) -> Binding md Rigid d ns -> Term d ns

  -- Normal primitives, never applied.
  SynPrimNormal : PrimitiveApplied PrimNorm Syntax NA ns -> Term Syntax ns
  -- Fully simplified primitives, cannot be reduced further, stable under OPEs.
  SimpPrimNormal : PrimitiveApplied PrimNorm Value Simplified ns -> Term Value ns

-- Some convenient shorthands

public export
0 Tm : Ctx -> Type
Tm = Term Syntax

public export
0 Ty : Ctx -> Type
Ty = Tm

public export
0 Val : Ctx -> Type
Val = Term Value

public export
0 ValTy : Ctx -> Type
ValTy = Val

public export
0 Env : Ctx -> Ctx -> Type
Env ms ns = Sub ms Val ns

public export
record AnyDomain (tm : Domain -> Ctx -> Type) (ns : Ctx) where
  constructor Choice
  syn : Lazy (tm Syntax ns)
  val : Lazy (tm Value ns)

public export
(WeakSized (tm Syntax), Weak (tm Value)) => WeakSized (AnyDomain tm) where
  weakS src dest e (Choice syn val) = Choice (weakS src dest e syn) (weak e val)
  
-- An atom is a term and a value at the same time.
public export
Atom : Ctx -> Type
Atom = AnyDomain Term

public export
AtomTy : Ctx -> Type
AtomTy = AnyDomain Term

-- An annotation is a type and a stage
public export
record Annot (ns : Ctx) where
  constructor MkAnnot
  ty : AtomTy ns
  sort : AtomTy ns
  stage : Stage

-- An annotation at a given stage, which is a type and a sort.
public export
record AnnotAt (s : Stage) (ns : Ctx) where
  constructor MkAnnotAt
  ty : AtomTy ns
  sort : AtomTy ns

namespace Annot
  -- Turn `ExprAt` into `Expr`
  public export
  packStage : {s : Stage} -> AnnotAt s ns -> Annot ns
  packStage (MkAnnotAt ty sort) = MkAnnot ty sort s

  public export
  forgetStage : (e : Annot ns) -> AnnotAt e.stage ns
  forgetStage (MkAnnot ty sort s) = MkAnnotAt ty sort

-- Version of ExprAt which also packages the stage
public export
record Expr (ns : Ctx) where
  constructor MkExpr
  tm : Atom ns
  annot : Annot ns

-- A typed expression at a given stage
public export
record ExprAt (s : Stage) (ns : Ctx) where
  constructor MkExprAt
  tm : Atom ns
  annot : AnnotAt s ns

namespace Expr
  -- Turn `ExprAt` into `Expr`
  public export
  packStage : {s : Stage} -> ExprAt s ns -> Expr ns
  packStage (MkExprAt tm a) = MkExpr tm (packStage a)

  public export
  forgetStage : (e : Expr ns) -> ExprAt e.annot.stage ns
  forgetStage (MkExpr tm a) = MkExprAt tm (forgetStage a)
  
  public export
  asTypeIn : Atom ns -> Annot ns -> Annot ns
  asTypeIn ty (MkAnnot sort _ s) = MkAnnot ty sort s

-- Helper to decide which `Expr` to pick based on an optional stage
public export
0 ExprAtMaybe : Maybe Stage -> Ctx -> Type
ExprAtMaybe Nothing = Expr
ExprAtMaybe (Just s) = ExprAt s

-- Turn `ExprAtMaybe` into `Expr`
public export
maybePackStage : {s : Maybe Stage} -> ExprAtMaybe s ns -> Expr ns
maybePackStage {s = Just s} (MkExprAt tm (MkAnnotAt ty sort)) = MkExpr tm (MkAnnot ty sort s)
maybePackStage {s = Nothing} x = x

-- Helpers to create syntax

public export
internalLam : (0 n : Ident) -> Tm (ns :< n) -> Tm ns
internalLam _ t = SynApps (SynBinding Mta Callable (Bound Mta InternalLam (Delayed t)) $$ [])

public export
closeWithLams : Size ns -> Tm ns -> Tm [<]
closeWithLams SZ t = t
closeWithLams (SS s) t = closeWithLams s (internalLam _ t)

public export
varIdx : Idx ns -> Tm ns
varIdx i = SynApps (SynVar (Index i) $$ [])

public export
varLvl : Lvl ns -> Val ns
varLvl l = SimpApps (ValVar (Level l) $$ [])

public export
sMtaLam : (n : Ident) -> Tm (ns :< n) -> Tm ns
sMtaLam n t = SynApps (SynBinding _ Callable (Bound _ (BindMtaLam n) (Delayed t)) $$ [])

public export
sObjLam : (n : Ident) -> Tm ns -> Tm ns -> Tm (ns :< n) -> Tm ns
sObjLam n ba bb t = SynApps (SynBinding _ Callable (Bound _ (BindObjLam n ba bb) (Delayed t)) $$ [])

public export
vMtaPi : (n : Ident) -> ValTy ns -> Body Value n ns -> ValTy ns
vMtaPi n ty body = RigidBinding _ (Bound _ (BindMtaPi n ty) body)

public export
sMtaPi : (n : Ident) -> Ty ns -> Ty (ns :< n) -> Ty ns
sMtaPi n ty body = SynApps (SynBinding _ Rigid (Bound _ (BindMtaPi n ty) (Delayed body)) $$ [])

public export
sObjPi : (n : Ident) -> Tm ns -> Tm ns -> Ty ns -> Ty (ns :< n) -> Ty ns
sObjPi n ba bb a b = SynApps (SynBinding _ Rigid (Bound _ (BindObjPi n ba bb a) (Delayed b)) $$ [])

public export
vObjPi : (n : Ident) -> Val ns -> Val ns -> ValTy ns -> Body Value n ns -> ValTy ns
vObjPi n ba bb ty body = RigidBinding _ (Bound _ (BindObjPi n ba bb ty) body)

public export
sPrim : {k : PrimitiveClass} -> {r : PrimitiveReducibility} -> Primitive k r ar -> Spine ar Tm ns -> Tm ns
sPrim {k = PrimNorm} p sp = SynPrimNormal (p $$ sp)
sPrim {k = PrimNeu} p sp = SynApps (PrimNeutral (p $$ sp) $$ [])

-- We can extend the variable search machinery to the syntax:

public export
var : (n : String) -> {auto prf : In n ns} -> Tm ns
var n {prf = prf} = SynApps (SynVar (Index (idx @{prf})) $$ [])

public export
varApp : (n : String) -> {auto prf : In n ns} -> Ident -> Term Syntax ns -> Tm ns
varApp n {prf = prf} a v = SynApps (SynVar (Index (idx @{prf})) $$ ((::) {a = a} v []))